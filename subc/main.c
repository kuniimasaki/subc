/* A recursive-descent parser generated by peg 0.1.18 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define YYRULECOUNT 119
#line 5 "main.leg"

;
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include <stdarg.h>
#include <errno.h>

#define TRACE	printf("TRACE %s:%d:%s\n", __FILE__, __LINE__, __PRETTY_FUNCTION__);

void fatal(char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    fprintf(stderr, "\n");
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, "\n");
    va_end(ap);
    exit(1);
}

#define USEGC 1

#if USEGC
# include <gc/gc.h>
# define MALLOC(N)	GC_malloc(N)
# define CALLOC(N,S)	GC_malloc((N)*(S))
# define REALLOC(P, N)	GC_realloc(P, N)
# define FREE(P)	GC_free(P)
# define STRDUP(S)	GC_strdup(S)
#else
# define MALLOC(N)	malloc(N)
# define CALLOC(N,S)	calloc((N), (S))
# define REALLOC(P, N)	realloc(P, N)
# define FREE(P)	free(P)
# define STRDUP(S)	strdup(S)
#endif

#define TAGBITS		2
#define TAGMASK		((1UL << TAGBITS) - 1)

#if TAGBITS >= 1
# define TAGPTR		0b00
# define TAGINT		0b01
# if TAGBITS >= 2
#   define TAGFLOAT	0b10
# endif
#endif

#define indexableSize(A)	(sizeof(A) / sizeof(*(A)))

typedef union Object Object, *oop;

#define YYSTYPE oop

#define _do_types(_)									\
    _(Undefined) _(Input) _(Token )_(Integer) _(Float) _(Array) _(Symbol) _(Pair)	\
    _(String) _(List)									\
    _(Pointer) _(Struct)								\
    _(Memory) _(Reference) _(Closure) _(Call) _(Block)					\
    _(Addressof) _(Dereference) _(Sizeof) _(Unary)					\
    _(Binary) _(Index) _(Member) _(Assign) _(Cast)					\
    _(While) _(For) _(If) _(Return) _(Continue) _(Break)				\
    _(Tvoid) _(Tchar) _(Tshort) _(Tint) _(Tlong) _(Tfloat) _(Tdouble)			\
    _(Tpointer) _(Tarray) _(Tstruct) _(Tfunction) _(Tetc)				\
    _(Scope) _(TypeName) _(Variable) _(Constant) _(Function) _(Primitive)		\
    _(VarDecls) _(TypeDecls)

#define _do_unaries(_)							\
    _(NEG) _(NOT) _(COM) _(PREINC) _(PREDEC) _(POSTINC) _(POSTDEC)

#define _do_binaries(_)					\
    _(MUL) _(DIV) _(MOD) _(ADD) _(SUB) _(SHL) _(SHR)	\
    _(LT) _(LE) _(GE) _(GT) _(EQ) _(NE)			\
    _(BAND) _(BXOR) _(BOR) _(LAND) _(LOR)

#define _(X) X,

typedef enum { _do_types(_)    } type_t;
typedef enum { _do_unaries(_)  } unary_t;
typedef enum { _do_binaries(_) } binary_t;

#undef _

#define _(X) #X,

char *unaryName(int op) {
    static char *names[] = { _do_unaries(_) };
    assert(0 <= op && op < indexableSize(names));
    return names[op];
}

char *binaryName(int op) {
    static char *names[] = { _do_binaries(_) };
    assert(0 <= op && op < indexableSize(names));
    return names[op];
}

#undef _

#define _do_primitives(_)							\
    _(printf) _(assert) _(malloc) _(free) _(exit) _(abort) _(atoi) _(sqrtf)

#define _(X) oop s_##X = 0;
_do_primitives(_)
#undef _

typedef oop (* prim_t)(int nargs, oop *arguments, oop environment);

typedef oop (*cvt_t)(oop input);

struct Undefined   { type_t _type; };
struct Input 	   { type_t _type;  char *name;  int line;  FILE *file;  oop next; };
struct Token	   { type_t _type;  char *text;  char *file;  int line; };
struct Integer 	   { type_t _type;  long value; };
struct Float 	   { type_t _type;  double value; };
struct Pointer 	   { type_t _type;  oop type, base;  int offset, isfree; };
struct Array 	   { type_t _type;  oop type, base;  int size; };
struct Struct 	   { type_t _type;  oop type, memory; };
struct Symbol  	   { type_t _type;  char *name; oop value; };
struct Pair   	   { type_t _type;  oop head, tail; };
struct String  	   { type_t _type;  int size;  char *elements; };
struct List   	   { type_t _type;  int size;  oop *elements; };
struct Memory      { type_t _type;  void *base;  size_t size;  int heap, free; };
struct Reference   { type_t _type;  oop target; };
struct Closure	   { type_t _type;  oop function, environment; };
struct Call   	   { type_t _type;  oop function, arguments, token; };
struct Block   	   { type_t _type;  oop statements; };
struct Addressof   { type_t _type;  oop rhs, token; };
struct Dereference { type_t _type;  oop rhs, token; };
struct Sizeof      { type_t _type;  oop rhs, size, token; };
struct Unary   	   { type_t _type;  unary_t  operator;  oop      rhs, token; };
struct Binary  	   { type_t _type;  binary_t operator;  oop lhs, rhs, token; };
struct Index  	   { type_t _type;  oop lhs, rhs, token; };
struct Member  	   { type_t _type;  oop lhs, name, token; };
struct Assign  	   { type_t _type;  oop lhs, rhs, token; };
struct Cast   	   { type_t _type;  oop type, rhs;  cvt_t converter; };
struct While   	   { type_t _type;  oop condition, expression; };
struct For   	   { type_t _type;  oop initialiser, condition, update, body; };
struct If      	   { type_t _type;  oop condition, consequent, alternate; };
struct Return  	   { type_t _type;  oop value; };
struct Continue	   { type_t _type; };
struct Break  	   { type_t _type; };

struct Tvoid	   { type_t _type; };
struct Tchar	   { type_t _type; };
struct Tshort	   { type_t _type; };
struct Tint	   	   { type_t _type; };
struct Tlong	   { type_t _type; };
struct Tfloat	   { type_t _type; };
struct Tdouble	   { type_t _type; };
struct Tpointer	   { type_t _type;  oop target;};
struct Tarray	   { type_t _type;  oop target;  oop size; };
struct Tstruct 	   { type_t _type;  oop tag, members;  int size; };
struct Tfunction   { type_t _type;  oop result, parameters; };
struct Tetc        { type_t _type; };

struct Scope	   { type_t _type;  oop names, values; };
struct TypeName	   { type_t _type;  oop name, type; };
struct Variable	   { type_t _type;  oop name, type, value,token; int isdead;};
struct Constant	   { type_t _type;  oop name, type, value; };
struct Function	   { type_t _type;  oop name, type, parameters, body, *code;  int variadic; };
struct Primitive   { type_t _type;  oop name, type, parameters; prim_t function;  int variadic; };
struct VarDecls	   { type_t _type;  oop type, variables; };
struct TypeDecls   { type_t _type;  oop type, typenames, token; };

union Object
{
    type_t             _type;
# define _(X) struct X X;
    _do_types(_)
# undef _
};

void println(oop obj);
char *toString(oop obj);

int opt_O = 0; // optimise (use VM)
int opt_v = 0; // verbose (print eval output, parser output, compiled code)
int opt_x = 0; // disable execution

Object _nil = { ._type = Undefined };

#define nil	(&_nil)

oop false = 0;
oop true  = 0;

#define isNil(O)	(nil   == (O))

oop _new(size_t size, type_t type)
{
    oop obj = MALLOC(size);
    obj->_type  = type;
    return obj;
}

#define new(TYPE) _new(sizeof(struct TYPE), TYPE)

#define CTOR0(Type)				\
    oop new##Type(void) {			\
	return new(Type);			\
    }

#define CTOR1(Type, A)				\
    oop new##Type(oop A) {			\
	oop obj = new(Type);			\
	obj->Type.A = A;			\
	return obj;				\
    }

#define CTOR2(Type, A, B)			\
    oop new##Type(oop A, oop B) {		\
	oop obj = new(Type);			\
	obj->Type.A = A;			\
	obj->Type.B = B;			\
	return obj;				\
    }

#define CTOR3(Type, A, B, C)			\
    oop new##Type(oop A, oop B, oop C) {	\
	oop obj = new(Type);			\
	obj->Type.A = A;			\
	obj->Type.B = B;			\
	obj->Type.C = C;			\
	return obj;				\
    }

#define CTOR4(Type, A, B, C, D)			\
    oop new##Type(oop A, oop B, oop C, oop D) {	\
	oop obj = new(Type);			\
	obj->Type.A = A;			\
	obj->Type.B = B;			\
	obj->Type.C = C;			\
	obj->Type.D = D;			\
	return obj;				\
    }

oop newInteger(long value)
{
# if TAGINT
    value <<= 1; // make room for bit on right
    value  |= 1; // set it to 1
    return (oop )(intptr_t)value;
# else
    oop obj = new(Integer);
    obj->Integer.value = value;
    return obj;
# endif
}

oop newPointer(oop type, oop base, int offset)
{
    oop obj = new(Pointer);
    obj->Pointer.type   = type;
    obj->Pointer.base   = base;
    obj->Pointer.offset = offset;
	obj->Pointer.isfree = 0;
    return obj;
}

oop newArray(oop type, oop base, int size)
{
    oop obj = new(Array);
    obj->Array.type = type;
    obj->Array.base = base;
    obj->Array.size = size;
    return obj;
}

CTOR2(Struct, type, memory);

oop newFloat(double value)
{
# if TAGFLOAT
    union { double d;  intptr_t i;  oop p; } u;
    u.d  = value;
    u.i &= ~TAGMASK;
    u.i |= TAGFLOAT;
    return u.p;
# else
    oop obj = new(Float);
    obj->Float.value = value;
    return obj;
# endif
}

char *typeName(int type)
{
    static char *typeNames[] = {
#     define _(X) #X,
	_do_types(_)
#     undef _
    };
    if (type < 0 || type >= indexableSize(typeNames)) fatal("unknown type %d", type);
    return typeNames[type];
}

type_t getType(oop obj)
{
# if TAGINT
    if ((intptr_t)obj & 1) return Integer;
# endif
# if TAGFLOAT
    if (((intptr_t)obj & TAGMASK) == TAGFLOAT) return Float;
# endif
    return obj->_type;
}

char *getTypeName(oop obj)	{ return typeName(getType(obj)); }

int is(type_t type, oop obj)	{ return type == getType(obj); }

oop _check(oop obj, type_t type, char *file, int line)
{
    if (type != getType(obj))
	fatal("%s:%d: expected %s, got %s", file, line, typeName(type), getTypeName(obj));
    return obj;
}

#define get(OBJ, TYPE, MEMBER)   	(_check(OBJ, TYPE, __FILE__, __LINE__)->TYPE.MEMBER)
#define set(OBJ, TYPE, MEMBER, VALUE)   (_check(OBJ, TYPE, __FILE__, __LINE__)->TYPE.MEMBER = (VALUE))

long _integerValue(oop obj)
{
# if TAGINT
    assert(is(Integer, obj));
    return (intptr_t)obj >> 1;
# else
    return get(obj, Integer,value);
# endif
}

double _floatValue(oop obj)
{
# if TAGFLOAT
    union { double d;  oop p; } u;
    u.p = obj;
    return u.d;
# else
    return get(obj, Float,value);
# endif
}

long integerValue(oop obj)
{
    switch (getType(obj)) {
	case Integer:	return _integerValue(obj);
	case Float:	return _floatValue(obj);
	default: 	break;
    }
    fatal("cannot convert %s to integer: %s", getTypeName(obj), toString(obj));
    return 0;
}

double floatValue(oop obj)
{
    switch (getType(obj)) {
	case Integer:	return _integerValue(obj);
	case Float:	return _floatValue(obj);
	default: 	break;
    }
    fatal("cannot convert type %d to float", getType(obj));
    return 0;
}

oop newSymbol(char *name)
{
    oop obj = new(Symbol);
    obj->Symbol.name = STRDUP(name);
    obj->Symbol.value = nil;
    return obj;
}

char *symbolName(oop obj)
{
    return get(obj, Symbol,name);
}

oop *symbols = 0;
int     nsymbols = 0;

oop intern(char *name)
{
    // find existing
    int lo = 0, hi = nsymbols - 1;
    while (lo <= hi) {
	int     mid = (lo + hi) / 2;
	oop sym = symbols[mid];
	int     cmp = strcmp(name, get(sym, Symbol,name));
	if      (cmp < 0) hi = mid - 1;
	else if (cmp > 0) lo = mid + 1;
	else              return sym; // target found
    }
    // create new
    oop sym = newSymbol(name); // sizeof Symbol
    // insert new symbol at index lo (where sym would have been found)
    symbols = REALLOC(symbols, sizeof(*symbols) * (nsymbols + 1));
    memmove(symbols + lo + 1,	// move entries to this location in the array
	    symbols + lo,	// move entries from this location
	    sizeof(*symbols) * (nsymbols - lo)	// element size * number to move
	);
    symbols[lo] = sym;
    ++nsymbols;
    return sym;
}

CTOR2(Pair, head, tail);

oop head(oop pair)	{ return get(pair, Pair,head); }
oop tail(oop pair)	{ return get(pair, Pair,tail); }

oop assoc(oop alist, oop key)
{
    while (is(Pair, alist)) {
	oop pair = head(alist);
	if (key == get(pair, Pair,head)) return pair;
	alist = tail(alist);
    }
    return nil;
}

oop newString(void)
{
    oop obj = new(String);
    obj->String.elements = 0; // empty string
    obj->String.size     = 0;
    return obj;
}

oop newStringWith(char *s)
{
    oop obj = new(String);
    obj->String.elements = STRDUP(s);
    obj->String.size     = strlen(s);
    return obj;
}

int String_append(oop string, int element)
{
    char *elements = get(string, String,elements);
    int       size = get(string, String,size);
    elements = REALLOC(elements, sizeof(*elements) * (size + 1));
    set(string, String,elements, elements);
    set(string, String,size, size + 1);
    return elements[size] = element;
}

char *String_cString(oop string)
{
    String_append(string, 0);
    get(string, String,size) -= 1;
    return get(string, String,elements);
}

char *String_appendAll(oop string, char *chars, int len)
{
    char *elements = get(string, String,elements);
    int       size = get(string, String,size);
    int    newSize = size + len;
    elements = REALLOC(elements, sizeof(*elements) * newSize);
    memcpy(elements + size, chars, len);
    set(string, String,elements, elements);
    set(string, String,size, newSize);
    return chars;
}

oop String_appendString(oop string, oop s)
{
    String_appendAll(string, get(s, String,elements), get(string, String,size));
    return s;
}

char *String_format(oop string, char *format, ...)
{
    static char *buf    = 0;
    static int   buflen = 0;
    int n = 0;
    for (;;) {
	va_list ap;
	va_start(ap, format);
	n = vsnprintf(buf, buflen, format, ap);
	va_end(ap);
	if (n < buflen) break;
	buflen = n + 1;
	buf = realloc(buf, sizeof(*buf) * buflen);
    }
    String_appendAll(string, buf, n);
    return buf;
}

#define List_do(ARR, VAR)							\
    for (oop do_list = (ARR), VAR = nil;  do_list;  do_list = 0)		\
	for (int do_size = get(do_list, List,size), do_index = 0;		\
	     do_index < do_size && (VAR = do_list->List.elements[do_index]);	\
	     ++do_index)

oop newList(void)
{
    oop obj = new(List);
    obj->List.elements = 0; // empty list
    obj->List.size     = 0;
    return obj;
}

oop List_append(oop list, oop element)
{
    oop *elements = get(list, List,elements);
    int      size = get(list, List,size);
    elements = REALLOC(elements, sizeof(*elements) * (size + 1));
    set(list, List,elements, elements);
    set(list, List,size, size + 1);
    return elements[size] = element;
}

oop newList1(oop a)
{
    oop obj = newList();
    List_append(obj, a);
    return obj;
}

oop newList2(oop a, oop b)
{
    oop obj = newList1(a);
    List_append(obj, b);
    return obj;
}

int List_size(oop list)
{
    return get(list, List,size);
}

oop List_last(oop list)
{
    int  size = get(list, List,size);
    oop *elts = get(list, List,elements);
    assert(size > 0);
    return elts[size - 1];
}

void kill_variable(oop obj){
	switch(getType(obj)){
		case Variable: {
			get(obj,Variable,isdead) = 1;
			//oop value = get(obj,Variable,value);
			//if(getType(value)==Pointer){
			//	if(getType(get(value, Pointer, base))==Variable){
			//		kill_variable(get(value, Pointer, base));
			//	}
			//}							
			break;
		}
		default: break;
	}
}

void kill_scpp(oop scope){
	if(getType(scope)==Scope){
		oop vals = get(scope, Scope, values);
		switch(getType(vals)){
			case List: {
				oop *elts=get(vals,List,elements);
				int size = get(vals,List, size);
				for (int i = 0;  i < size;  ++i){
					kill_variable(elts[i]);
				}
				break;
			}
			default: break;
		}
	}
}

oop List_popLast(oop list)
{
    int  size = get(list, List,size);
    oop *elts = get(list, List,elements);
    assert(size > 0);
    oop  last = elts[--size];
	oop tlast = elts[size];
	kill_scpp(tlast);
    elts[size] = nil;
    set(list, List,size, size);
    return last;
}

oop List_get(oop list, int index)
{
    oop *elements = get(list, List,elements);
    int      size     = get(list, List,size);
    if (index >= size) fatal("list index %d out of bounds %d", index, size);
    return elements[index];
}

oop List_set(oop list, int index, oop element)
{
    oop *elements = get(list, List,elements);
    int      size     = get(list, List,size);
    if (index >= size) fatal("list index %d out of bounds %d", index, size);
    return elements[index] = element;
}

int List_equal(oop list, oop brray)
{
    if (List_size(list) != List_size(brray)) return 0;
    List_do(list, a) {
	oop b = get(brray, List,elements)[do_index];
	if (a != b) return 0;
    }
    return 1;
}

#if 0

struct keyval { oop key, val; };

oop newMap(void)
{
    return newList();
}

int Map_find(oop map, oop key)
{
    int            size = get(map, List,size) / 2;
    struct keyval *kvs  = (struct keyval *)get(map, List,elements);
    int lo = 0, hi = size - 1;
    while (lo <= hi) {
	int mi = (lo + hi) / 2;
	if      (key < kvs[mi].key)	hi = mi - 1;
	else if (key > kvs[mi].key)	lo = mi + 1;
	else				return mi;
    }
    return -1 - lo; // not found, encoding expected location
}

oop Map_set(oop map, oop key, oop val)
{
    int            size  = get(map, List,size) / 2;
    struct keyval *kvs   = (struct keyval *)get(map, List,elements);
    int            index = Map_find(map, key);
    if (index > 0) return kvs[index].val = val;
    index = -1 - index;
    int last = size++;
    kvs = REALLOC(kvs, sizeof(*kvs) * size);
    while (last > index) {
	kvs[last] = kvs[last - 1];
	--last;
    }
    kvs[index].key = key;
    return kvs[index].val = val;
}

oop Map_get(oop map, oop key)
{
    struct keyval *kvs   = (struct keyval *)get(map, List,elements);
    int            index = Map_find(map, key);
    if (index < 0) fatal("key not found in map");
    return kvs[index].val;
}

#endif

oop newMemory(void *base, size_t size, int heap)
{
  oop obj = new(Memory);
  obj->Memory.base = base;
  obj->Memory.size = size;
  obj->Memory.heap = heap;
  obj->Memory.free = 0;
  return obj;
}

CTOR1(Reference,   target);
CTOR2(Closure,     function, environment);
CTOR3(Call,    	   function, arguments, token);
CTOR1(Block,   	   statements);
CTOR2(Addressof,   rhs, token);
CTOR2(Dereference, rhs, token);

oop newSizeof(oop operand, oop token)
{
    oop obj = new(Sizeof);
    obj->Sizeof.rhs      = operand;
    obj->Sizeof.size     = nil;
    obj->Sizeof.token    = token;
    return obj;
}

oop newUnary(unary_t operator, oop operand, oop token)
{
    oop obj = new(Unary);
    obj->Unary.operator = operator;
    obj->Unary.rhs      = operand;
    obj->Unary.token    = token;
    return obj;
}

oop newBinary(binary_t operator, oop lhs, oop rhs, oop token)
{
    oop obj = new(Binary);
    obj->Binary.operator = operator;
    obj->Binary.lhs      = lhs;
    obj->Binary.rhs      = rhs;
    obj->Binary.token    = token;
    return obj;
}

CTOR3(Index,  lhs, rhs,  token);
CTOR3(Member, lhs, name, token);
CTOR3(Assign, lhs, rhs,  token);

oop newCast(oop type, oop rhs)
{
    oop obj = new(Cast);
    obj->Cast.type      = type;
    obj->Cast.rhs       = rhs;
    obj->Cast.converter = 0;
    return obj;
}

CTOR2(While,  condition, expression);
CTOR4(For,    initialiser, condition, update, body);
CTOR3(If,     condition, consequent, alternate);
CTOR1(Return, value);
CTOR0(Continue);
CTOR0(Break);

CTOR0(Tvoid);
CTOR0(Tchar);
CTOR0(Tshort);
CTOR0(Tint);
CTOR0(Tlong);
CTOR0(Tfloat);
CTOR0(Tdouble);

int isTypeName(oop obj)
{
    switch (getType(obj)) {
	case Tvoid:
	case Tchar:
	case Tshort:
	case Tint:
	case Tlong:
	case Tfloat:
	case Tdouble:
	case TypeName:	return 1;
	default:	break;
    }
    return 0;
}

oop s_etc    = 0;
oop t_etc    = 0;
oop t_void   = 0;
oop t_char   = 0;
oop t_short  = 0;
oop t_int    = 0;
oop t_long   = 0;
oop t_float  = 0;
oop t_double = 0;
oop t_pvoid  = 0;
oop t_pchar  = 0;
oop t_ppchar = 0;
static oop pointers = 0;
oop newTpointer(oop target)
{
    if (!pointers) pointers = newList();
    List_do(pointers, t)
	if (target == get(t, Tpointer,target))
	    return t; // uniqe types allow comparison by identity
    oop obj = new(Tpointer);
    obj->Tpointer.target = target;
    List_append(pointers, obj);
    return obj;
}


oop newTarray(oop target, oop size)
{
    static oop arrays = 0;
    if (!arrays) arrays = newList();
    List_do(arrays, t)
	if (target == get(t, Tarray,target) && size == get(t, Tarray,size))
	    return t; // uniqe types allow comparison by identity
    oop obj = new(Tarray);
    obj->Tarray.target = target;
    obj->Tarray.size   = size;
    List_append(arrays, obj);
    return obj;
}

oop tags = 0;

oop newTstruct(oop tag, oop members)
{
    if (!isNil(tag)) {
	List_do(tags, t) {
	    if (tag == get(t, Tstruct,tag)) {
		if (!is(Tstruct, t))
		    fatal("tag '%s' redeclared as different type", symbolName(tag));
		oop oldmembers = get(t, Tstruct,members);
		if (!isNil(oldmembers) && !isNil(members)) {
		    fatal("tag '%s' redefined", symbolName(tag));
		}
		if (isNil(oldmembers) && !isNil(members))
		    set(t, Tstruct,members, members);
		return t; // uniqe types allow comparison by identity
	    }
	}
    }
    oop obj = new(Tstruct);
    obj->Tstruct.tag     = tag;
    obj->Tstruct.members = members;
    obj->Tstruct.size    = -1;         // incomplete type when negative
    List_append(tags, obj);
    return obj;
}

oop vars2types(oop vars)
{
    oop types = newList();
    List_do(vars, var)
	List_append(types, get(var, Variable,type));
    return types;
}

oop newTfunction(oop result, oop parameters)
{
    static oop functions = 0;
    if (!functions) functions = newList();
    List_do(functions, t) {
	oop tres = get(t, Tfunction,result);
	oop tpar = get(t, Tfunction,parameters);
	if (result == tres && List_equal(parameters, tpar))
	    return t; // uniqe types allow comparison by identity
    }
    oop obj = new(Tfunction);
    obj->Tfunction.result     = result;
    obj->Tfunction.parameters = parameters;
    List_append(functions, obj);
    return obj;
}

CTOR0(Tetc);

oop newScope(void)
{
    oop obj = new(Scope);
    obj->Scope.names  = newList();
    obj->Scope.values = newList();
    return obj;
}

int Scope_find(oop scope, oop name)
{
    oop  names = get(scope, Scope,names);
    int  size  = get(names, List,size);
    oop *elts  = get(names, List,elements);
    for (int i = size;  i--;) // fixme: binary search
	if (name == elts[i])
	    return i;
    return -1;
}

oop scopes = 0;

void Scope_begin(void)
{
    List_append(scopes, newScope());
}

void Scope_end(void)
{
    List_popLast(scopes);
}

oop Scope_lookup(oop name)
{
    int  n    = get(scopes, List,size);
    oop *elts = get(scopes, List,elements);
    while (n--) {
	oop scope = elts[n];
	int i = Scope_find(scope, name);
	if (i >= 0) return get(get(scope, Scope,values), List,elements)[i];
    }
    return 0; // NOTE: 0 means undefined (rather than nil, which means uninitialised)
}

oop Scope_local(oop name)
{
    oop scope = List_last(scopes);
    int i = Scope_find(scope, name);
    if (i >= 0) return get(get(scope, Scope,values), List,elements)[i];
    return 0; // NOTE: 0 means undefined (rather than nil, which means uninitialised)
}

oop Scope_redeclare(oop name, oop value)
{
    int  n    = get(scopes, List,size);
    oop *elts = get(scopes, List,elements);
    while (n--) {
	oop scope = elts[n];
	int i = Scope_find(scope, name);
	if (i >= 0) return get(get(scope, Scope,values), List,elements)[i] = value;
    }
    return 0; // NOTE: 0 means undefined (rather than nil, which means uninitialised)
}

CTOR2(TypeName, name, type);
CTOR3(Constant, name, type, value);

oop newVariable(oop name, oop type, oop value, int isdead)
{
    oop obj = new(Variable);
    obj->Variable.name       = name;
    obj->Variable.type       = type;
    obj->Variable.value      = value;
    obj->Variable.isdead     = isdead;
    return obj;
}



oop newFunction(oop name, oop type, oop parameters, oop body)
{
    oop obj = new(Function);
    obj->Function.name       = name;
    obj->Function.type       = type;
    obj->Function.parameters = parameters;
    obj->Function.body       = body;
    obj->Function.code       = 0;
    obj->Function.variadic   = 0;
    return obj;
}

oop newPrimitive(oop name, oop type, oop parameters, prim_t function)
{
    oop obj = new(Primitive);
    obj->Primitive.name       = name;
    obj->Primitive.type       = type;
    obj->Primitive.parameters = parameters;
    obj->Primitive.function   = function;
    obj->Primitive.variadic   = 0;
    return obj;
}

oop makeType(oop base, oop type)
{
    switch (getType(type)) {
	case Undefined:	return base;
	case Symbol:	return base;
	case Index:	return makeType(base, get(type, Index,lhs));
	case Assign:	return makeType(base, get(type, Assign,lhs));
	case Tpointer:	return newTpointer(makeType(base, get(type, Tpointer,target)));
	case Tarray:	return newTarray(makeType(base, get(type, Tarray,target)),
					 get(type, Tarray,size));
	case Tfunction:	return newTfunction(base, get(type, Tfunction,parameters));
	default:	break;
    }
    fatal("cannot make type from delcaration: %s %s", toString(base), toString(type));
    return 0;
}

oop makeName(oop decl)
{
    switch (getType(decl)) {
	case Undefined:
	case Symbol:	return decl;
	case Index:	return makeName(get(decl, Index,lhs));
	case Assign:	return makeName(get(decl, Assign,lhs));
	case Tpointer:	return makeName(get(decl, Tpointer,target));
	case Tarray:	return makeName(get(decl, Tarray,target));
	case Tfunction:	return makeName(get(decl, Tfunction,result));
	default:	break;
    }
    fatal("cannot make name from delcaration: %s", toString(decl));
    return 0;
}

oop makeBaseType(oop type)
{
    if (is(Symbol, type)) {
	oop value = Scope_lookup(type);
	if (!value || !is(TypeName, value))
	    fatal("identifier '%s' does not name a type", type);
	type = get(value, TypeName,type);
    }
    return type;
}

void VarDecls_append(oop vds, oop decl)
{
    List_append(get(vds, VarDecls,variables), decl);
}

oop newVarDecls(oop type, oop decl)
{
    oop obj = new(VarDecls);
    obj->VarDecls.type         = type;
    obj->VarDecls.variables    = newList();
    VarDecls_append(obj, decl);
    return obj;
}

void TypeDecls_append(oop tds, oop decl)
{
    List_append(get(tds, TypeDecls,typenames), decl);
}

oop newTypeDecls(oop type, oop decl, oop token)
{
    oop obj = new(TypeDecls);
    obj->TypeDecls.type         = type;
    obj->TypeDecls.typenames    = newList();
    obj->TypeDecls.token        = token;
    TypeDecls_append(obj, decl);
    return obj;
}

#undef CTOR4
#undef CTOR3
#undef CTOR2
#undef CTOR1
#undef CTOR0

oop baseType(oop type)
{
    switch (getType(type)) {
	case Symbol: {
	    oop value = Scope_lookup(type);
	    if (!value || !is(TypeName, value))
		fatal("baseType: '%s' does not name a type");
	    return baseType(get(value, TypeName,type));
	}
	case Tvoid:
	case Tchar:
	case Tshort:
	case Tint:
	case Tlong:
	case Tfloat:
	case Tdouble:
	case Tstruct:	return type;
	case Tpointer:	return baseType(get(type, Tpointer,target));
	case Tarray:	return baseType(get(type, Tarray,target));
	case Tfunction:	return baseType(get(type, Tfunction,result));
	default:	fatal("cannot find base type of %s", getTypeName(type));
    }
    return nil;
}

oop toStringOn(oop obj, oop str);

void declareStringOn(oop type, oop name, oop str)
{
    switch (getType(type)) {
	case Symbol: {
	    oop value = Scope_lookup(type);
	    if (!value || !is(TypeName, value))
		fatal("declareString: '%s' does not name a type");
	    declareStringOn(get(value, TypeName,type), name, str);
	    return;
	}
	case Tvoid:
	case Tchar:
	case Tshort:
	case Tint:
	case Tlong:
	case Tfloat:
	case Tdouble:
	    toStringOn(name, str);
	    break;
	case Tpointer:
	    String_append(str, '*');
	    declareStringOn(get(type, Tpointer,target), name, str);
	    break;
	case Tarray: {
	    declareStringOn(get(type, Tarray,target), name, str);
	    String_append(str, '[');
	    toStringOn(get(type, Tarray,size), str);
	    String_append(str, ']');
	    break;
	}
	case Tstruct: {
	    String_format(str, "struct %s %s", toString(get(type, Tstruct,tag)), symbolName(name));
	    break;
	}
	case Tfunction: {
	    declareStringOn(get(type, Tfunction,result), name, str);
	    String_append(str, '(');
	    List_do(get(type, Tfunction,parameters), parameter) {
		if (do_index) String_appendAll(str, ", ", 2);
		toStringOn(parameter, str);
	    }
	    String_append(str, ')');
	    break;
	}
	default:
	    fatal("cannot convert to declaration: %s", getTypeName(type));
    }
}

char *declareString(oop type, oop name)
{
    oop str = newString();
    declareStringOn(type, name, str);
    String_append(str, 0);
    return get(str, String,elements);
}

oop toStringOn(oop obj, oop str)
{
    switch (getType(obj)) {
	case Undefined:
	    String_appendAll(str, "<NIL>", 5);
	    break;
	case Token: {
	    String_format(str, "%s:%d: ", get(obj, Token,file), get(obj, Token,line));
	    break;
	}
	case Integer:
	    String_format(str, "%d", _integerValue(obj));
	    break;
	case Float: {
	    String_format(str, "%f", _floatValue(obj));
	    break;
	}
	case Pointer: {
	    oop base = get(obj, Pointer,base);
	    switch (getType(base)) {
		case Integer:
		    String_format(str, "<%s %p", toString(get(obj, Pointer,type)), (void *)(intptr_t)_integerValue(base));
		    break;
		case Variable:
		    String_format(str, "<%s &%s", toString(get(obj, Pointer,type)), symbolName(get(base, Variable,name)));
		    break;
		case Memory:
		    String_format(str, "<%s %p[%d]", toString(get(obj, Pointer,type)), get(base, Memory,base), get(base, Memory,size));
		    break;
		default:
		    fatal("cannot convert pointer base %s to string", toString(base));
		    break;
	    }
	    String_format(str, "%+d>", get(obj, Pointer,offset));
	    break;
	}
	case Array: {
	    oop base = get(obj, Array,base);
	    oop type = get(obj, Array,type);
	    String_format(str, "[%s ", toString(type));
	    switch (getType(base)) {
		case Integer:
		    String_format(str, "%p", (void *)(intptr_t)_integerValue(base));
		    break;
		case Variable:
		    String_format(str, "&%s", symbolName(get(base, Variable,name)));
		    break;
		case Memory:
		    String_format(str, "%p[%d]", get(base, Memory,base), get(base, Memory,size));
		    break;
		default:
		    fatal("cannot convert array base %s to string", toString(base));
		    break;
	    }
	    String_format(str, "%+d]", get(obj, Array,size));
	    break;
	}
	case Symbol:
	    String_format(str, "%s", get(obj, Symbol,name));
	    break;
	case String: {
	    String_append(str, '"');
	    String_appendString(str, obj);
	    String_append(str, '"');
	    break;
	}
	case Memory: {
	    String_format(str, "<%p+%zd>", get(obj, Memory,base), get(obj, Memory,size));
	    break;
	}
	case Cast: {
	    String_append(str, '(');
	    toStringOn(get(obj, Cast,type), str);
	    String_append(str, ')');
	    toStringOn(get(obj, Cast,rhs), str);
	    break;
	}
	case Dereference: {
	    String_append(str, '*');
	    toStringOn(get(obj, Dereference,rhs), str);
	    break;
	}
	case Addressof: {
	    String_append(str, '&');
	    toStringOn(get(obj, Addressof,rhs), str);
	    break;
	}
	case Sizeof: {
	    String_format(str, "sizeof(%d)", toString(get(obj, Sizeof,rhs)));
	    break;
	}
	case Unary: {
	    char *name = 0;
	    oop rhs = get(obj, Unary,rhs);
	    switch (get(obj, Unary,operator)) {
		case NEG: 	name = "-";	break;
		case NOT: 	name = "!";	break;
		case COM: 	name = "~";	break;
		case PREINC:	String_format(str, "++");  toStringOn(rhs, str);  return str;
		case PREDEC:	String_format(str, "--");  toStringOn(rhs, str);  return str;
		case POSTINC:	toStringOn(rhs, str);  String_format(str, "++");  return str;
		case POSTDEC:	toStringOn(rhs, str);  String_format(str, "--");  return str;
	    }
	    String_format(str, "%s", name);
	    toStringOn(rhs, str);
	    break;
	}
	case Binary: {
	    char *name = 0;
	    char *lhs = toString(get(obj, Binary,lhs));
	    char *rhs = toString(get(obj, Binary,rhs));
	    switch (get(obj, Binary,operator)) {
		case MUL:	name = "*";	break;
		case DIV:	name = "/";	break;
		case MOD:	name = "%";	break;
		case ADD:	name = "+";	break;
		case SUB:	name = "-";	break;
		case SHL:	name = "<<";	break;
		case SHR:	name = ">>";	break;
		case LT:	name = "<";	break;
		case LE:	name = "<=";	break;
		case GE:	name = ">=";	break;
		case GT:	name = ">";	break;
		case EQ:	name = "==";	break;
		case NE:	name = "!=";	break;
		case BAND:	name = "&";	break;
		case BXOR:	name = "^";	break;
		case BOR:	name = "|";	break;
		case LAND:	name = "&&";	break;
		case LOR:	name = "||";	break;
	    }
	    String_format(str, "%s %s %s", lhs, name, rhs);
	    break;
	}
	case Index: {
	    toStringOn(get(obj, Index,lhs), str);
	    String_append(str, '[');
	    toStringOn(get(obj, Index,rhs), str);
	    String_append(str, ']');
	    break;
	}
	case Member: {
	    toStringOn(get(obj, Member,lhs), str);
	    String_append(str, '.');
	    toStringOn(get(obj, Member,name), str);
	    break;
	}
	case Assign: {
	    toStringOn(get(obj, Assign,lhs), str);
	    String_format(str, " = ");
	    toStringOn(get(obj, Assign,rhs), str);
	    break;
	}
	case Call: {
	    toStringOn(get(obj, Call,function), str);
	    String_append(str, '(');
	    List_do(get(obj, Call,arguments), arg) {
		if (do_index) String_format(str, ", ");
		toStringOn(arg, str);
	    }
	    String_append(str, ')');
	    break;
	}
	case If: {
	    String_format(str, "if (");
	    toStringOn(get(obj, If,condition), str);
	    String_format(str, ") ");
	    toStringOn(get(obj, If,consequent), str);
	    if (nil != get(obj, If,alternate)) {
		String_format(str, "; else ");
		toStringOn(get(obj, If,alternate), str);
	    }
	    break;
	}
	case While: {
	    String_format(str, "while (");
	    toStringOn(get(obj, While,condition), str);
	    String_format(str, ") ");
	    toStringOn(get(obj, While,expression), str);
	    break;
	}
	case For: {
	    String_format(str, "for (");
	    toStringOn(get(obj, For,initialiser), str);
	    String_format(str, "; ");
	    toStringOn(get(obj, For,condition), str);
	    String_format(str, "; ");
	    toStringOn(get(obj, For,update), str);
	    String_format(str, ") ");
	    toStringOn(get(obj, For,body), str);
	    break;
	}
	case Tvoid:	String_format(str, "void");	break;
	case Tchar:	String_format(str, "char");	break;
	case Tshort:	String_format(str, "short");	break;
	case Tint:	String_format(str, "int");	break;
	case Tlong:	String_format(str, "long");	break;
	case Tfloat:	String_format(str, "float");	break;
	case Tdouble:	String_format(str, "double");	break;
	case Tpointer: {
	    oop target = get(obj, Tpointer,target);
	    toStringOn(target, str);
	    if (isTypeName(target)) String_append(str, ' ');
	    String_append(str, '*');
	    break;
	}
	case Tarray: {
	    oop target = get(obj, Tarray,target);
	    oop size   = get(obj, Tarray,size);
	    toStringOn(target, str);
	    String_append(str, '[');
	    if (nil != size) toStringOn(size, str);
	    String_append(str, ']');
	    break;
	}
	case Tstruct: {
	    String_format(str, "struct");
	    oop tag     = get(obj, Tstruct,tag);
	    oop members = get(obj, Tstruct,members);
	    if (nil != tag) String_format(str, " %s", symbolName(tag));
	    else if (nil != members) {
		String_format(str, " {");
		List_do(members, vdecls) toStringOn(vdecls, str);
		String_format(str, "}");
	    }
	    break;
	}
	case Tfunction: {
	    oop result = get(obj, Tfunction,result);
	    oop params = get(obj, Tfunction,parameters);
	    toStringOn(result, str);
	    String_append(str, '(');
	    List_do(params, param) {
		if (do_index) String_appendAll(str, ", ", 2);
		toStringOn(param, str);
	    }
	    String_append(str, ')');
	    break;
	}
	case Reference: {
	    String_append(str, '&');
	    toStringOn(get(obj, Reference,target), str);
	    break;
	}
	case Variable: {
	    oop type = get(obj, Variable,type);
	    oop name = get(obj, Variable,name);
	    toStringOn(baseType(type), str);
	    String_append(str, ' ');
	    if (nil != name)
		declareStringOn(type, name, str);
	    else
		toStringOn(type, str);
	    break;
	}
	case Function: {
	    toStringOn(get(get(obj, Function,type), Tfunction,result), str);
	    String_append(str, ' ');
	    toStringOn(get(obj, Function,name), str);
	    String_append(str, '(');
	    oop params = get(obj, Function,parameters);
	    List_do(params, param) {
		if (do_index) String_appendAll(str, ", ", 2);
		toStringOn(param, str);
	    }
	    String_append(str, ')');
	    break;
	}
	case Primitive: {
	    String_format(str, "%s", symbolName(get(obj, Primitive,name)));
	    break;
	}
	case VarDecls: {
	    oop vars = get(obj, VarDecls,variables);
	    List_do(vars, var) {
		if (do_index) String_appendAll(str, ", ", 2);
		toStringOn(var, str);
	    }
	    break;
	}
	case TypeDecls: {
	    oop types = get(obj, TypeDecls,typenames);
	    List_do(types, type) {
		if (do_index) String_appendAll(str, ", ", 2);
		toStringOn(type, str);
	    }
	    break;
	}
	default:
	    fatal("cannot convert %s to string", getTypeName(obj));
	    break;
    }
    return str;
}

char *toString(oop obj)
{
    oop str = toStringOn(obj, newString());
    String_append(str, 0);
    return get(str, String,elements);
}

char *tokloc(oop token)
{
    if (Token == getType(token)) return toString(token);
    return "";
}

void printiln(oop obj, int indent)
{
    printf("%*s", indent*2, "");
    switch (getType(obj)) {
	case Undefined:	    printf("nil\n");	    			break;
	case Input:	    printf("<%s>\n", get(obj, Input,name));	break;
	case Token:	    printf("Token<%s:%d %s>\n",
				   get(obj, Token,file),
				   get(obj, Token,line),
				   get(obj, Token,text));	break;
	case Integer:	    printf("%ld\n", integerValue(obj));		break;
	case Float:	    printf("%f\n",  floatValue(obj));		break;
	case Pointer: {
		if(get(obj, Pointer, isfree))fatal("freed memory read");
	    printf("POINTER %s [%d]\n", toString(get(obj, Pointer,type)), get(obj, Pointer,offset));
		printiln(get(obj, Pointer,base), indent+1);
	    break;
	}
	case Array: {
	    printf("ARRAY %s [%d]\n", toString(get(obj, Array,type)), get(obj, Array,size));
	    printiln(get(obj, Array,base), indent+1);
	    break;
	}
	case Struct: {
	    printf("STRUCT %s @ %s\n",
		   symbolName(get(get(obj, Struct,type), Tstruct,tag)),
		   toString(get(obj, Struct,memory)));
	    break;
	}
	case Symbol:	    printf("%s\n",  symbolName  (obj));	    	break;
	case Pair: {
	    printf("PAIR\n");
	    printiln(head(obj), indent+1);
	    printiln(tail(obj), indent+1);
	    break;
	}
	case String: {
	    char *elts = get(obj, String,elements);
	    int   size = get(obj, String,size);
	    printf("STRING %d \"", size);
	    for (int i = 0;  i < size;  ++i) {
		int c = elts[i];
		if ('"' == c)
		    printf("\\\"");
		else if (31 < c && c < 127)
		    putchar(c);
		else
		    printf("\\x%02x", c);
	    }
	    printf("\"\n");
	    break;
	}
	case List: {
	    oop *elts = get(obj, List,elements);
	    int size = get(obj, List,size);
	    printf("LIST %d\n", size);
	    for (int i = 0;  i < size;  ++i)
		printiln(elts[i], indent+1);
	    break;
	}
	case Primitive: {
	    printf("PRIMITIVE\n");
	    printiln(get(obj, Primitive,name), indent+1);
	    printiln(get(obj, Primitive,type), indent+1);
	    break;
	}
	case Memory: {
	    printf("MEMORY %p + %zd\n", get(obj, Memory,base), get(obj, Memory,size));
	    break;
	}
	case Reference: {
	    printf("REFERENCE\n");
	    printiln(get(obj, Reference,target), indent+1);
	    break;
	}
	case Closure: {
	    printf("CLOSURE\n");
	    printiln(get(obj, Closure,function), indent+1);
	    break;
	}
	case Call: {
	    printf("CALL\n");
	    printiln(get(obj, Call,function ), indent+1);
	    printiln(get(obj, Call,arguments), indent+1);
	    break;
	}
	case Block: {
	    printf("BLOCK\n");
	    printiln(get(obj, Block,statements), indent+1);
	    break;
	}
	case Addressof: {
	    printf("ADDRESSOF\n");
	    printiln(get(obj, Addressof,rhs), indent+1);
	    break;
	}
	case Dereference: {
	    printf("DEREFERENCE\n");
	    printiln(get(obj, Dereference,rhs), indent+1);
	    break;
	}
	case Sizeof: {
	    printf("SIZEOF ");
	    println(get(obj, Sizeof,size));
	    printiln(get(obj, Sizeof,rhs), indent+1);
	    break;
	}
	case Unary: {
	    switch (get(obj, Unary,operator)) {
		case NEG: 	printf("NEG\n");   	break;
		case NOT: 	printf("NOT\n");   	break;
		case COM: 	printf("COM\n");   	break;
		case PREINC:	printf("PREINC\n");   	break;
		case PREDEC:	printf("PREDEC\n");   	break;
		case POSTINC:	printf("POSTINC\n");	break;
		case POSTDEC:	printf("POSTDEC\n");   	break;
	    }
	    printiln(get(obj, Unary,rhs), indent+1);
	    break;
	}
	case Binary: {
	    switch (get(obj, Binary,operator)) {
		case MUL: 	printf("MUL\n"); 	break;
		case DIV: 	printf("DIV\n"); 	break;
		case MOD: 	printf("MOD\n"); 	break;
		case ADD: 	printf("ADD\n"); 	break;
		case SUB: 	printf("SUB\n"); 	break;
		case SHL: 	printf("SHL\n"); 	break;
		case SHR: 	printf("SHR\n"); 	break;
		case LT: 	printf("LT\n"); 	break;
		case LE: 	printf("LE\n"); 	break;
		case GE: 	printf("GE\n"); 	break;
		case GT: 	printf("GT\n"); 	break;
		case EQ: 	printf("EQ\n"); 	break;
		case NE: 	printf("NE\n"); 	break;
		case BAND: 	printf("BAND\n"); 	break;
		case BXOR: 	printf("BXOR\n"); 	break;
		case BOR: 	printf("BOR\n"); 	break;
		case LAND: 	printf("LAND\n"); 	break;
		case LOR: 	printf("LOR\n"); 	break;
	    }
	    printiln(get(obj, Binary,lhs), indent+1);
	    printiln(get(obj, Binary,rhs), indent+1);
	    break;
	}
	case Index: {
	    printf("INDEX\n");
	    printiln(get(obj, Index,lhs), indent+1);
	    printiln(get(obj, Index,rhs), indent+1);
	    break;
	}
	case Member: {
	    printf("MEMBER\n");
	    printiln(get(obj, Member,lhs ), indent+1);
	    printiln(get(obj, Member,name), indent+1);
	    break;
	}
	case Assign: {
	    printf("ASSIGN\n");
	    printiln(get(obj, Assign,lhs), indent+1);
	    printiln(get(obj, Assign,rhs), indent+1);
	    break;
	}
	case Cast: {
	    printf("CAST\n");
	    printiln(get(obj, Cast,type      ), indent+1);
	    printiln(get(obj, Cast,rhs       ), indent+1);
	    break;
	}
	case While: {
	    printf("WHILE\n");
	    printiln(get(obj, While,condition), indent+1);
	    printiln(get(obj, While,expression), indent+1);
	    break;
	}
	case For: {
	    printf("For\n");
	    printiln(get(obj, For,initialiser), indent+1);
	    printiln(get(obj, For,condition),   indent+1);
	    printiln(get(obj, For,update),      indent+1);
	    printiln(get(obj, For,body),        indent+1);
	    break;
	}
	case If: {
	    printf("IF\n");
	    printiln(get(obj, If,condition),  indent+1);
	    printiln(get(obj, If,consequent), indent+1);
	    printiln(get(obj, If,alternate),  indent+1);
	    break;
	}
	case Return: {
	    printf("RETURN\n");
	    printiln(get(obj, Return,value),  indent+1);
	    break;
	}
	case Continue: {
	    printf("CONTINUE\n");
	    break;
	}
	case Break: {
	    printf("BREAK\n");
	    break;
	}
	case Tvoid:	printf("<void:1>\n");	break;
	case Tchar:	printf("<char:1>\n");	break;
	case Tshort:	printf("<short:2>\n");	break;
	case Tint:	printf("<int:4>\n");	break;
	case Tlong:	printf("<long:8>\n");	break;
	case Tfloat:	printf("<float:4>\n");	break;
	case Tdouble:	printf("<double:8>\n");	break;
	case Tetc:	printf("<...>\n");	break;
	case Tpointer: {
	    printf("Tpointer\n");
	    printiln(get(obj, Tpointer,target), indent+1);
	    break;
	}
	case Tarray: {
	    printf("Tarray\n");
	    printiln(get(obj, Tarray,size  ), indent+1);
	    printiln(get(obj, Tarray,target), indent+1);
	    break;
	}
	case Tstruct: {
	    printf("Tstruct\n");
	    printiln(get(obj, Tstruct,tag    ),  indent+1);
	    if (indent < 1)
		printiln(get(obj, Tstruct,members),  indent+1);
	    break;
	}
	case Tfunction: {
	    printf("Tfunction\n");
	    printiln(get(obj, Tfunction,result    ),  indent+1);
	    printiln(get(obj, Tfunction,parameters),  indent+1);
	    break;
	}
	case VarDecls: {
	    printf("VarDecls\n");
	    printiln(get(obj, VarDecls,type        ),  indent+1);
	    printiln(get(obj, VarDecls,variables   ),  indent+1);
	    break;
	}
	case TypeDecls: {
	    printf("TypeDecls\n");
	    printiln(get(obj, TypeDecls,type        ),  indent+1);
	    printiln(get(obj, TypeDecls,typenames   ),  indent+1);
	    break;
	}
	case Scope: {
	    printf("SCOPE ");
	    oop names = get(obj, Scope,names);
	    List_do(names, name) printf(" %s", toString(name));
	    printf("\n");
	    break;
	}
	case TypeName: {
	    printf("TypeName\n");
	    printiln(get(obj, TypeName,name), indent+1);
	    printiln(get(obj, TypeName,type), indent+1);
	    break;
	}
	case Variable: {
	    printf("VARIABLE ");
		printf("isdead:%d\n",get(obj, Variable,isdead ));
	    printiln(get(obj, Variable,name ), indent+1);
	    printiln(get(obj, Variable,type ), indent+1);
	    printiln(get(obj, Variable,value), indent+1);
		
	    break;
	}
	case Constant: {
	    printf("Constant\n");
	    printiln(get(obj, Constant,name ), indent+1);
	    printiln(get(obj, Constant,type ), indent+1);
	    printiln(get(obj, Constant,value), indent+1);
	    break;
	};
	case Function: {
	    printf("Function %s\n", toString(get(obj, Function,name)));
	    printiln(get(obj, Function,type      ), indent+1);
	    printiln(get(obj, Function,parameters), indent+1);
	    printiln(get(obj, Function,body      ), indent+1);
	    break;
	}
    }
}

void println(oop obj)
{
    printiln(obj, 0);
}

oop input = 0;

oop pushInput(char *name, FILE *file)
{
    oop obj = new(Input);
    obj->Input.name = STRDUP(name);
    obj->Input.line = 1;
    obj->Input.file = file;
    obj->Input.next = input;
    input = obj;
    return input;
}

void popInput(void)
{
    if (!input) return;
    FILE *file = get(input, Input,file);
    oop obj = input;
    input = get(obj, Input,next);
    if (file) {
	fclose(file);
	set(obj, Input,file, 0);
    }
}

FILE *sysOpen(char *path)
{
    char abspath[1024];
    snprintf(abspath, sizeof(abspath), "include/%s", path);
    FILE *fp = fopen(abspath, "r");
    if (!fp) fatal("#include <%s>: %s", path, strerror(errno));
    return fp;
}

FILE *usrOpen(char *path)
{
    FILE *fp = fopen(path, "r");
    if (!fp) fatal("#include \"%s\": %s", path, strerror(errno));
    return fp;
}

int getChar(char *buf)
{
    if (input && get(input, Input,file)) {
	int c = getc(get(input, Input,file));
	if (c != EOF) {
	    *buf = c;
	    if ('\n' == c) get(input, Input,line) += 1;
	    return 1;
	}
    }
    return 0;
}

#define YY_INPUT(buf, result, max_size) { result = getChar(buf); }

YYSTYPE yysval = 0;

int errorLine = 0;

void expected(oop where, char *what)
{
    fatal("%s:%d: %s expected near: %.*s",
	  get(input, Input,name), errorLine,
	  what, get(where, String,size), get(where, String,elements));
}

oop eval(oop exp);
oop preval(oop exp);

int lineNo = 1;

oop newToken(char *text)
{
    oop obj = new(Token);
    obj->Token.text = text;
    assert(input);
    obj->Token.file = get(input, Input,name);
    obj->Token.line = lineNo;
    return obj;
}

oop names = 0;
oop lines = 0;

void startInput(char *name)
{
    if (!names) names = newList();
    if (!lines) lines = newList();
    List_append(names, newStringWith(name));
    List_append(lines, newInteger(lineNo));
    lineNo = 1;
}

void endInput(void)
{
    if (lines && List_size(lines)) {
	lineNo = _integerValue(List_popLast(lines));
	List_popLast(names);
    }
}


#ifndef YY_MALLOC
#define YY_MALLOC(C, N)		malloc(N)
#endif
#ifndef YY_REALLOC
#define YY_REALLOC(C, P, N)	realloc(P, N)
#endif
#ifndef YY_FREE
#define YY_FREE(C, P)		free(P)
#endif
#ifndef YY_LOCAL
#define YY_LOCAL(T)	static T
#endif
#ifndef YY_ACTION
#define YY_ACTION(T)	static T
#endif
#ifndef YY_RULE
#define YY_RULE(T)	static T
#endif
#ifndef YY_PARSE
#define YY_PARSE(T)	T
#endif
#ifndef YYPARSE
#define YYPARSE		yyparse
#endif
#ifndef YYPARSEFROM
#define YYPARSEFROM	yyparsefrom
#endif
#ifndef YYRELEASE
#define YYRELEASE	yyrelease
#endif
#ifndef YY_BEGIN
#define YY_BEGIN	( yy->__begin= yy->__pos, 1)
#endif
#ifndef YY_END
#define YY_END		( yy->__end= yy->__pos, 1)
#endif
#ifdef YY_DEBUG
# define yyprintf(args)	fprintf args
#else
# define yyprintf(args)
#endif
#ifndef YYSTYPE
#define YYSTYPE	int
#endif
#ifndef YY_STACK_SIZE
#define YY_STACK_SIZE 128
#endif

#ifndef YY_BUFFER_SIZE
#define YY_BUFFER_SIZE 1024
#endif

#ifndef YY_PART

typedef struct _yycontext yycontext;
typedef void (*yyaction)(yycontext *yy, char *yytext, int yyleng);
typedef struct _yythunk { int begin, end;  yyaction  action;  struct _yythunk *next; } yythunk;

struct _yycontext {
  char     *__buf;
  int       __buflen;
  int       __pos;
  int       __limit;
  char     *__text;
  int       __textlen;
  int       __begin;
  int       __end;
  int       __textmax;
  yythunk  *__thunks;
  int       __thunkslen;
  int       __thunkpos;
  YYSTYPE   __;
  YYSTYPE  *__val;
  YYSTYPE  *__vals;
  int       __valslen;
#ifdef YY_CTX_MEMBERS
  YY_CTX_MEMBERS
#endif
};

#ifdef YY_CTX_LOCAL
#define YY_CTX_PARAM_	yycontext *yyctx,
#define YY_CTX_PARAM	yycontext *yyctx
#define YY_CTX_ARG_	yyctx,
#define YY_CTX_ARG	yyctx
#ifndef YY_INPUT
#define YY_INPUT(yy, buf, result, max_size)		\
  {							\
    int yyc= getchar();					\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#else
#define YY_CTX_PARAM_
#define YY_CTX_PARAM
#define YY_CTX_ARG_
#define YY_CTX_ARG
yycontext _yyctx= { 0, 0 };
yycontext *yyctx= &_yyctx;
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)			\
  {							\
    int yyc= getchar();					\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#endif

YY_LOCAL(int) yyrefill(yycontext *yy)
{
  int yyn;
  while (yy->__buflen - yy->__pos < 512)
    {
      yy->__buflen *= 2;
      yy->__buf= (char *)YY_REALLOC(yy, yy->__buf, yy->__buflen);
    }
#ifdef YY_CTX_LOCAL
  YY_INPUT(yy, (yy->__buf + yy->__pos), yyn, (yy->__buflen - yy->__pos));
#else
  YY_INPUT((yy->__buf + yy->__pos), yyn, (yy->__buflen - yy->__pos));
#endif
  if (!yyn) return 0;
  yy->__limit += yyn;
  return 1;
}

YY_LOCAL(int) yymatchDot(yycontext *yy)
{
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  ++yy->__pos;
  return 1;
}

YY_LOCAL(int) yymatchChar(yycontext *yy, int c)
{
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  if ((unsigned char)yy->__buf[yy->__pos] == c)
    {
      ++yy->__pos;
      yyprintf((stderr, "  ok   yymatchChar(yy, %c) @ %s\n", c, yy->__buf+yy->__pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchChar(yy, %c) @ %s\n", c, yy->__buf+yy->__pos));
  return 0;
}

YY_LOCAL(int) yymatchString(yycontext *yy, const char *s)
{
  int yysav= yy->__pos;
  while (*s)
    {
      if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
      if (yy->__buf[yy->__pos] != *s)
        {
          yy->__pos= yysav;
          return 0;
        }
      ++s;
      ++yy->__pos;
    }
  return 1;
}

YY_LOCAL(int) yymatchClass(yycontext *yy, unsigned char *bits)
{
  int c;
  if (yy->__pos >= yy->__limit && !yyrefill(yy)) return 0;
  c= (unsigned char)yy->__buf[yy->__pos];
  if (bits[c >> 3] & (1 << (c & 7)))
    {
      ++yy->__pos;
      yyprintf((stderr, "  ok   yymatchClass @ %s\n", yy->__buf+yy->__pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchClass @ %s\n", yy->__buf+yy->__pos));
  return 0;
}

YY_LOCAL(void) yyDo(yycontext *yy, yyaction action, int begin, int end)
{
  while (yy->__thunkpos >= yy->__thunkslen)
    {
      yy->__thunkslen *= 2;
      yy->__thunks= (yythunk *)YY_REALLOC(yy, yy->__thunks, sizeof(yythunk) * yy->__thunkslen);
    }
  yy->__thunks[yy->__thunkpos].begin=  begin;
  yy->__thunks[yy->__thunkpos].end=    end;
  yy->__thunks[yy->__thunkpos].action= action;
  ++yy->__thunkpos;
}

YY_LOCAL(int) yyText(yycontext *yy, int begin, int end)
{
  int yyleng= end - begin;
  if (yyleng <= 0)
    yyleng= 0;
  else
    {
      while (yy->__textlen < (yyleng + 1))
	{
	  yy->__textlen *= 2;
	  yy->__text= (char *)YY_REALLOC(yy, yy->__text, yy->__textlen);
	}
      memcpy(yy->__text, yy->__buf + begin, yyleng);
    }
  yy->__text[yyleng]= '\0';
  return yyleng;
}

YY_LOCAL(void) yyDone(yycontext *yy)
{
  int pos;
  for (pos= 0;  pos < yy->__thunkpos;  ++pos)
    {
      yythunk *thunk= &yy->__thunks[pos];
      int yyleng= thunk->end ? yyText(yy, thunk->begin, thunk->end) : thunk->begin;
      yyprintf((stderr, "DO [%d] %p %s\n", pos, thunk->action, yy->__text));
      thunk->action(yy, yy->__text, yyleng);
    }
  yy->__thunkpos= 0;
}

YY_LOCAL(void) yyCommit(yycontext *yy)
{
  if ((yy->__limit -= yy->__pos))
    {
      memmove(yy->__buf, yy->__buf + yy->__pos, yy->__limit);
    }
  yy->__begin -= yy->__pos;
  yy->__end -= yy->__pos;
  yy->__pos= yy->__thunkpos= 0;
}

YY_LOCAL(int) yyAccept(yycontext *yy, int tp0)
{
  if (tp0)
    {
      fprintf(stderr, "accept denied at %d\n", tp0);
      return 0;
    }
  else
    {
      yyDone(yy);
      yyCommit(yy);
    }
  return 1;
}

YY_LOCAL(void) yyPush(yycontext *yy, char *text, int count)
{
  yy->__val += count;
  while (yy->__valslen <= yy->__val - yy->__vals)
    {
      long offset= yy->__val - yy->__vals;
      yy->__valslen *= 2;
      yy->__vals= (YYSTYPE *)YY_REALLOC(yy, yy->__vals, sizeof(YYSTYPE) * yy->__valslen);
      yy->__val= yy->__vals + offset;
    }
}
YY_LOCAL(void) yyPop(yycontext *yy, char *text, int count)   { yy->__val -= count; }
YY_LOCAL(void) yySet(yycontext *yy, char *text, int count)   { yy->__val[count]= yy->__; }

#endif /* YY_PART */

#define	YYACCEPT	yyAccept(yy, yythunkpos0)

YY_RULE(int) yy_comment(yycontext *yy); /* 119 */
YY_RULE(int) yy_space(yycontext *yy); /* 118 */
YY_RULE(int) yy_blank(yycontext *yy); /* 117 */
YY_RULE(int) yy_STATIC(yycontext *yy); /* 116 */
YY_RULE(int) yy_ENUM(yycontext *yy); /* 115 */
YY_RULE(int) yy_UNION(yycontext *yy); /* 114 */
YY_RULE(int) yy_alnum(yycontext *yy); /* 113 */
YY_RULE(int) yy_alpha(yycontext *yy); /* 112 */
YY_RULE(int) yy_keyword(yycontext *yy); /* 111 */
YY_RULE(int) yy_HEX(yycontext *yy); /* 110 */
YY_RULE(int) yy_OCT(yycontext *yy); /* 109 */
YY_RULE(int) yy_escaped(yycontext *yy); /* 108 */
YY_RULE(int) yy_mkStr(yycontext *yy); /* 107 */
YY_RULE(int) yy_char(yycontext *yy); /* 106 */
YY_RULE(int) yy_string(yycontext *yy); /* 105 */
YY_RULE(int) yy_integer(yycontext *yy); /* 104 */
YY_RULE(int) yy_float(yycontext *yy); /* 103 */
YY_RULE(int) yy_ARROW(yycontext *yy); /* 102 */
YY_RULE(int) yy_args(yycontext *yy); /* 101 */
YY_RULE(int) yy_value(yycontext *yy); /* 100 */
YY_RULE(int) yy_postfix(yycontext *yy); /* 99 */
YY_RULE(int) yy_cast(yycontext *yy); /* 98 */
YY_RULE(int) yy_tnamdec(yycontext *yy); /* 97 */
YY_RULE(int) yy_SIZEOF(yycontext *yy); /* 96 */
YY_RULE(int) yy_MMINUS(yycontext *yy); /* 95 */
YY_RULE(int) yy_PPLUS(yycontext *yy); /* 94 */
YY_RULE(int) yy_TILDE(yycontext *yy); /* 93 */
YY_RULE(int) yy_PLING(yycontext *yy); /* 92 */
YY_RULE(int) yy_PCENT(yycontext *yy); /* 91 */
YY_RULE(int) yy_SLASH(yycontext *yy); /* 90 */
YY_RULE(int) yy_MINUS(yycontext *yy); /* 89 */
YY_RULE(int) yy_PLUS(yycontext *yy); /* 88 */
YY_RULE(int) yy_prod(yycontext *yy); /* 87 */
YY_RULE(int) yy_RSHIFT(yycontext *yy); /* 86 */
YY_RULE(int) yy_LSHIFT(yycontext *yy); /* 85 */
YY_RULE(int) yy_sum(yycontext *yy); /* 84 */
YY_RULE(int) yy_GRTR(yycontext *yy); /* 83 */
YY_RULE(int) yy_GRTREQ(yycontext *yy); /* 82 */
YY_RULE(int) yy_LESSEQ(yycontext *yy); /* 81 */
YY_RULE(int) yy_LESS(yycontext *yy); /* 80 */
YY_RULE(int) yy_shift(yycontext *yy); /* 79 */
YY_RULE(int) yy_NEQUAL(yycontext *yy); /* 78 */
YY_RULE(int) yy_EQUAL(yycontext *yy); /* 77 */
YY_RULE(int) yy_inequal(yycontext *yy); /* 76 */
YY_RULE(int) yy_AND(yycontext *yy); /* 75 */
YY_RULE(int) yy_equal(yycontext *yy); /* 74 */
YY_RULE(int) yy_HAT(yycontext *yy); /* 73 */
YY_RULE(int) yy_bitand(yycontext *yy); /* 72 */
YY_RULE(int) yy_BAR(yycontext *yy); /* 71 */
YY_RULE(int) yy_bitxor(yycontext *yy); /* 70 */
YY_RULE(int) yy_ANDAND(yycontext *yy); /* 69 */
YY_RULE(int) yy_bitor(yycontext *yy); /* 68 */
YY_RULE(int) yy_BARBAR(yycontext *yy); /* 67 */
YY_RULE(int) yy_logand(yycontext *yy); /* 66 */
YY_RULE(int) yy_logor(yycontext *yy); /* 65 */
YY_RULE(int) yy_unary(yycontext *yy); /* 64 */
YY_RULE(int) yy_assign(yycontext *yy); /* 63 */
YY_RULE(int) yy_BREAK(yycontext *yy); /* 62 */
YY_RULE(int) yy_CONTINU(yycontext *yy); /* 61 */
YY_RULE(int) yy_RETURN(yycontext *yy); /* 60 */
YY_RULE(int) yy_ELSE(yycontext *yy); /* 59 */
YY_RULE(int) yy_IF(yycontext *yy); /* 58 */
YY_RULE(int) yy_FOR(yycontext *yy); /* 57 */
YY_RULE(int) yy_cond(yycontext *yy); /* 56 */
YY_RULE(int) yy_WHILE(yycontext *yy); /* 55 */
YY_RULE(int) yy_stmt(yycontext *yy); /* 54 */
YY_RULE(int) yy_EXTERN(yycontext *yy); /* 53 */
YY_RULE(int) yy_block(yycontext *yy); /* 52 */
YY_RULE(int) yy_funid(yycontext *yy); /* 51 */
YY_RULE(int) yy_DOT(yycontext *yy); /* 50 */
YY_RULE(int) yy_initelt(yycontext *yy); /* 49 */
YY_RULE(int) yy_expr(yycontext *yy); /* 48 */
YY_RULE(int) yy_agrinit(yycontext *yy); /* 47 */
YY_RULE(int) yy_ETC(yycontext *yy); /* 46 */
YY_RULE(int) yy_pdecl(yycontext *yy); /* 45 */
YY_RULE(int) yy_params(yycontext *yy); /* 44 */
YY_RULE(int) yy_RBRAK(yycontext *yy); /* 43 */
YY_RULE(int) yy_expropt(yycontext *yy); /* 42 */
YY_RULE(int) yy_LBRAK(yycontext *yy); /* 41 */
YY_RULE(int) yy_idopt(yycontext *yy); /* 40 */
YY_RULE(int) yy_RPAREN(yycontext *yy); /* 39 */
YY_RULE(int) yy_LPAREN(yycontext *yy); /* 38 */
YY_RULE(int) yy_ddector(yycontext *yy); /* 37 */
YY_RULE(int) yy_STAR(yycontext *yy); /* 36 */
YY_RULE(int) yy_initor(yycontext *yy); /* 35 */
YY_RULE(int) yy_ASSIGN(yycontext *yy); /* 34 */
YY_RULE(int) yy_RBRACE(yycontext *yy); /* 33 */
YY_RULE(int) yy_mkList(yycontext *yy); /* 32 */
YY_RULE(int) yy_LBRACE(yycontext *yy); /* 31 */
YY_RULE(int) yy_members(yycontext *yy); /* 30 */
YY_RULE(int) yy_STRUCT(yycontext *yy); /* 29 */
YY_RULE(int) yy_id(yycontext *yy); /* 28 */
YY_RULE(int) yy_struct(yycontext *yy); /* 27 */
YY_RULE(int) yy_DOUBLE(yycontext *yy); /* 26 */
YY_RULE(int) yy_FLOAT(yycontext *yy); /* 25 */
YY_RULE(int) yy_LONG(yycontext *yy); /* 24 */
YY_RULE(int) yy_INT(yycontext *yy); /* 23 */
YY_RULE(int) yy_SHORT(yycontext *yy); /* 22 */
YY_RULE(int) yy_CHAR(yycontext *yy); /* 21 */
YY_RULE(int) yy_VOID(yycontext *yy); /* 20 */
YY_RULE(int) yy_inidecl(yycontext *yy); /* 19 */
YY_RULE(int) yy_SEMI(yycontext *yy); /* 18 */
YY_RULE(int) yy_COMMA(yycontext *yy); /* 17 */
YY_RULE(int) yy_decltor(yycontext *yy); /* 16 */
YY_RULE(int) yy_tname(yycontext *yy); /* 15 */
YY_RULE(int) yy_TYPEDEF(yycontext *yy); /* 14 */
YY_RULE(int) yy_vardecl(yycontext *yy); /* 13 */
YY_RULE(int) yy_primdef(yycontext *yy); /* 12 */
YY_RULE(int) yy_fundefn(yycontext *yy); /* 11 */
YY_RULE(int) yy_typedec(yycontext *yy); /* 10 */
YY_RULE(int) yy_INCLUDE(yycontext *yy); /* 9 */
YY_RULE(int) yy_HASH(yycontext *yy); /* 8 */
YY_RULE(int) yy_eol(yycontext *yy); /* 7 */
YY_RULE(int) yy_error(yycontext *yy); /* 6 */
YY_RULE(int) yy_tldecl(yycontext *yy); /* 5 */
YY_RULE(int) yy_include(yycontext *yy); /* 4 */
YY_RULE(int) yy_interp(yycontext *yy); /* 3 */
YY_RULE(int) yy__(yycontext *yy); /* 2 */
YY_RULE(int) yy_start(yycontext *yy); /* 1 */

YY_ACTION(void) yy_1_SEMI(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_SEMI\n"));
  {
#line 2140
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_COMMA(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_COMMA\n"));
  {
#line 2139
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_RBRACE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_RBRACE\n"));
  {
#line 2138
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_LBRACE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_LBRACE\n"));
  {
#line 2137
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_RBRAK(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_RBRAK\n"));
  {
#line 2136
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_LBRAK(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_LBRAK\n"));
  {
#line 2135
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_RPAREN(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_RPAREN\n"));
  {
#line 2134
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_LPAREN(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_LPAREN\n"));
  {
#line 2133
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_TILDE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_TILDE\n"));
  {
#line 2132
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_PLING(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_PLING\n"));
  {
#line 2131
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_PCENT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_PCENT\n"));
  {
#line 2130
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_SLASH(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_SLASH\n"));
  {
#line 2129
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_RSHIFT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_RSHIFT\n"));
  {
#line 2128
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_LSHIFT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_LSHIFT\n"));
  {
#line 2127
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_GRTR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_GRTR\n"));
  {
#line 2126
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_GRTREQ(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_GRTREQ\n"));
  {
#line 2125
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_LESSEQ(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_LESSEQ\n"));
  {
#line 2124
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_LESS(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_LESS\n"));
  {
#line 2123
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_NEQUAL(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_NEQUAL\n"));
  {
#line 2122
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_EQUAL(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_EQUAL\n"));
  {
#line 2121
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_HAT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_HAT\n"));
  {
#line 2120
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_ANDAND(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ANDAND\n"));
  {
#line 2119
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_AND(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_AND\n"));
  {
#line 2118
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_BARBAR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_BARBAR\n"));
  {
#line 2117
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_BAR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_BAR\n"));
  {
#line 2116
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_STAR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_STAR\n"));
  {
#line 2115
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MMINUS(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MMINUS\n"));
  {
#line 2114
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_MINUS(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_MINUS\n"));
  {
#line 2113
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_PPLUS(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_PPLUS\n"));
  {
#line 2112
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_PLUS(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_PLUS\n"));
  {
#line 2111
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_ASSIGN(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ASSIGN\n"));
  {
#line 2110
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_HASH(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_HASH\n"));
  {
#line 2109
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_ETC(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ETC\n"));
  {
#line 2108
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_ARROW(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ARROW\n"));
  {
#line 2107
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_DOT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_DOT\n"));
  {
#line 2106
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_BREAK(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_BREAK\n"));
  {
#line 2105
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_CONTINU(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_CONTINU\n"));
  {
#line 2104
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_RETURN(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_RETURN\n"));
  {
#line 2103
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_FOR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_FOR\n"));
  {
#line 2102
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_WHILE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_WHILE\n"));
  {
#line 2101
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_ELSE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ELSE\n"));
  {
#line 2100
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_IF(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_IF\n"));
  {
#line 2099
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_SIZEOF(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_SIZEOF\n"));
  {
#line 2098
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_ENUM(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ENUM\n"));
  {
#line 2095
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_UNION(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_UNION\n"));
  {
#line 2094
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_STRUCT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_STRUCT\n"));
  {
#line 2093
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_DOUBLE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_DOUBLE\n"));
  {
#line 2092
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_FLOAT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_FLOAT\n"));
  {
#line 2091
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_LONG(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_LONG\n"));
  {
#line 2090
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_INT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_INT\n"));
  {
#line 2089
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_SHORT(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_SHORT\n"));
  {
#line 2088
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_CHAR(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_CHAR\n"));
  {
#line 2087
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_VOID(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_VOID\n"));
  {
#line 2086
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_TYPEDEF(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_TYPEDEF\n"));
  {
#line 2085
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_STATIC(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_STATIC\n"));
  {
#line 2084
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_EXTERN(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_EXTERN\n"));
  {
#line 2083
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_INCLUDE(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_INCLUDE\n"));
  {
#line 2082
   __ = newToken(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_eol(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_eol\n"));
  {
#line 2078
   lineNo += 1 ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_id(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_id\n"));
  {
#line 2066
   __ = intern(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_idopt(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_idopt\n"));
  {
#line 2064
   __ = nil ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_13_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_13_escaped\n"));
  {
#line 2059
   __ = newInteger(strtol(yytext, 0, 16)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_12_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_12_escaped\n"));
  {
#line 2058
   __ = newInteger(strtol(yytext, 0, 16)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_11_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_11_escaped\n"));
  {
#line 2057
   __ = newInteger(strtol(yytext, 0,  8)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_10_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_10_escaped\n"));
  {
#line 2056
   __ = newInteger('\\') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_9_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_9_escaped\n"));
  {
#line 2055
   __ = newInteger('\"') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_8_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_8_escaped\n"));
  {
#line 2054
   __ = newInteger('\'') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_7_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_escaped\n"));
  {
#line 2053
   __ = newInteger('\v') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_6_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_escaped\n"));
  {
#line 2052
   __ = newInteger('\t') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_5_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_escaped\n"));
  {
#line 2051
   __ = newInteger('\r') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_4_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_escaped\n"));
  {
#line 2050
   __ = newInteger('\n') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_3_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_escaped\n"));
  {
#line 2049
   __ = newInteger('\f') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_escaped\n"));
  {
#line 2048
   __ = newInteger('\b') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_escaped(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_escaped\n"));
  {
#line 2047
   __ = newInteger('\a') ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_char(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_char\n"));
  {
#line 2045
   __ = newInteger(yytext[0]) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_1_char(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_char\n"));
  {
#line 2044
   __ = e ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_2_string(yycontext *yy, char *yytext, int yyleng)
{
#define c yy->__val[-1]
#define s yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_string\n"));
  {
#line 2042
   __ = s ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef c
#undef s
}
YY_ACTION(void) yy_1_string(yycontext *yy, char *yytext, int yyleng)
{
#define c yy->__val[-1]
#define s yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_string\n"));
  {
#line 2041
   String_append(s, _integerValue(c)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef c
#undef s
}
YY_ACTION(void) yy_1_mkStr(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_mkStr\n"));
  {
#line 2038
   __ = newString() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_4_integer(yycontext *yy, char *yytext, int yyleng)
{
#define c yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_integer\n"));
  {
#line 2036
   __ = c ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef c
}
YY_ACTION(void) yy_3_integer(yycontext *yy, char *yytext, int yyleng)
{
#define c yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_integer\n"));
  {
#line 2035
   __ = newInteger(strtol(yytext, 0, 10)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef c
}
YY_ACTION(void) yy_2_integer(yycontext *yy, char *yytext, int yyleng)
{
#define c yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_integer\n"));
  {
#line 2034
   __ = newInteger(strtol(yytext, 0,  2)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef c
}
YY_ACTION(void) yy_1_integer(yycontext *yy, char *yytext, int yyleng)
{
#define c yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_integer\n"));
  {
#line 2033
   __ = newInteger(strtol(yytext, 0, 16)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef c
}
YY_ACTION(void) yy_3_float(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_float\n"));
  {
#line 2031
   __ = newFloat(atof(yytext)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_float(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_float\n"));
  {
#line 2030
   __ = newFloat(atof(yytext)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_float(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_float\n"));
  {
#line 2029
   __ = newFloat(atof(yytext)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_mkList(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_mkList\n"));
  {
#line 2027
   __ = newList() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_value(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_value\n"));
  {
#line 2021
   __ = e ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_3_args(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define a yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_args\n"));
  {
#line 2017
   __ = a ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef a
}
YY_ACTION(void) yy_2_args(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define a yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_args\n"));
  {
#line 2016
   List_append(a, e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef a
}
YY_ACTION(void) yy_1_args(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define a yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_args\n"));
  {
#line 2015
   List_append(a, e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef a
}
YY_ACTION(void) yy_7_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define t yy->__val[-3]
#define v yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_postfix\n"));
  {
#line 2012
   __ = v ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
#undef t
#undef v
}
YY_ACTION(void) yy_6_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define t yy->__val[-3]
#define v yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_postfix\n"));
  {
#line 2011
   v = newMember(newDereference(v, t), i, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
#undef t
#undef v
}
YY_ACTION(void) yy_5_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define t yy->__val[-3]
#define v yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_postfix\n"));
  {
#line 2010
   v = newMember(v, i, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
#undef t
#undef v
}
YY_ACTION(void) yy_4_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define t yy->__val[-3]
#define v yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_postfix\n"));
  {
#line 2009
   v = newUnary(POSTDEC, v, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
#undef t
#undef v
}
YY_ACTION(void) yy_3_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define t yy->__val[-3]
#define v yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_postfix\n"));
  {
#line 2008
   v = newUnary(POSTINC, v, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
#undef t
#undef v
}
YY_ACTION(void) yy_2_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define t yy->__val[-3]
#define v yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_postfix\n"));
  {
#line 2007
   v = newIndex(v, i, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
#undef t
#undef v
}
YY_ACTION(void) yy_1_postfix(yycontext *yy, char *yytext, int yyleng)
{
#define i yy->__val[-1]
#define a yy->__val[-2]
#define t yy->__val[-3]
#define v yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_postfix\n"));
  {
#line 2006
   v = newCall(v, a, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef i
#undef a
#undef t
#undef v
}
YY_ACTION(void) yy_1_tnamdec(yycontext *yy, char *yytext, int yyleng)
{
#define d yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_tnamdec\n"));
  {
#line 2004
   __ = makeType(t, d) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef d
#undef t
}
YY_ACTION(void) yy_1_cast(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_cast\n"));
  {
#line 2002
   __ = newCast(t, r) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_9_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_9_unary\n"));
  {
#line 1996
   __ = newSizeof(r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_8_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_8_unary\n"));
  {
#line 1995
   __ = newSizeof(r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_7_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_unary\n"));
  {
#line 1993
   __ = newUnary(PREDEC, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_6_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_unary\n"));
  {
#line 1992
   __ = newUnary(PREINC, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_5_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_unary\n"));
  {
#line 1991
   __ = newAddressof(    r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_4_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_unary\n"));
  {
#line 1990
   __ = newDereference(  r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_3_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_unary\n"));
  {
#line 1989
   __ = newUnary(COM,   	r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_2_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_unary\n"));
  {
#line 1988
   __ = newUnary(NOT,   	r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_1_unary(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_unary\n"));
  {
#line 1987
   __ = newUnary(NEG,   	r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
}
YY_ACTION(void) yy_4_prod(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_prod\n"));
  {
#line 1985
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_3_prod(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_prod\n"));
  {
#line 1984
   l  = newBinary(MOD, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_prod(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_prod\n"));
  {
#line 1983
   l  = newBinary(DIV, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_prod(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_prod\n"));
  {
#line 1982
   l  = newBinary(MUL, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_3_sum(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_sum\n"));
  {
#line 1980
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_sum(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_sum\n"));
  {
#line 1979
   l  = newBinary(SUB, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_sum(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_sum\n"));
  {
#line 1978
   l  = newBinary(ADD, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_3_shift(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_shift\n"));
  {
#line 1976
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_shift(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_shift\n"));
  {
#line 1975
   l  = newBinary(SHR, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_shift(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_shift\n"));
  {
#line 1974
   l  = newBinary(SHL, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_5_inequal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_inequal\n"));
  {
#line 1972
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_4_inequal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_inequal\n"));
  {
#line 1971
   l  = newBinary(GT, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_3_inequal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_inequal\n"));
  {
#line 1970
   l  = newBinary(GE, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_inequal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_inequal\n"));
  {
#line 1969
   l  = newBinary(LE, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_inequal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_inequal\n"));
  {
#line 1968
   l  = newBinary(LT, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_3_equal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_equal\n"));
  {
#line 1966
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_equal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_equal\n"));
  {
#line 1965
   l  = newBinary(NE, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_equal(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_equal\n"));
  {
#line 1964
   l  = newBinary(EQ, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_bitand(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_bitand\n"));
  {
#line 1962
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_bitand(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_bitand\n"));
  {
#line 1961
   l  = newBinary(BAND, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_bitxor(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_bitxor\n"));
  {
#line 1959
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_bitxor(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_bitxor\n"));
  {
#line 1958
   l  = newBinary(BXOR, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_bitor(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_bitor\n"));
  {
#line 1956
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_bitor(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_bitor\n"));
  {
#line 1955
   l  = newBinary(BOR, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_logand(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_logand\n"));
  {
#line 1953
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_logand(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_logand\n"));
  {
#line 1952
   l  = newBinary(LAND, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_2_logor(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_logor\n"));
  {
#line 1950
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_logor(yycontext *yy, char *yytext, int yyleng)
{
#define r yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_logor\n"));
  {
#line 1949
   l  = newBinary(LOR, l, r, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef r
#undef t
#undef l
}
YY_ACTION(void) yy_1_assign(yycontext *yy, char *yytext, int yyleng)
{
#define x yy->__val[-1]
#define t yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_assign\n"));
  {
#line 1946
   __ = newAssign(l, x, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef x
#undef t
#undef l
}
YY_ACTION(void) yy_1_expropt(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_expropt\n"));
  {
#line 1942
   __ = nil ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_cond(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_cond\n"));
  {
#line 1940
   __ = e ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
}
YY_ACTION(void) yy_8_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_8_stmt\n"));
  {
#line 1936
   __ = e ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_7_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_stmt\n"));
  {
#line 1934
   __ = newBreak() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_6_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_stmt\n"));
  {
#line 1933
   __ = newContinue() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_5_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_stmt\n"));
  {
#line 1932
   __ = newReturn(e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_4_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_stmt\n"));
  {
#line 1930
   __ = newIf(c, s, nil) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_3_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_stmt\n"));
  {
#line 1929
   __ = newIf(c, s,   t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_2_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_stmt\n"));
  {
#line 1927
   __ = newFor(i, c, u, b) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_1_stmt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define b yy->__val[-3]
#define u yy->__val[-4]
#define i yy->__val[-5]
#define s yy->__val[-6]
#define c yy->__val[-7]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_stmt\n"));
  {
#line 1923
   __ = newWhile(c, s) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef b
#undef u
#undef i
#undef s
#undef c
}
YY_ACTION(void) yy_3_block(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define s yy->__val[-2]
#define b yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_block\n"));
  {
#line 1920
   expected(e, "statement") ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef s
#undef b
}
YY_ACTION(void) yy_2_block(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define s yy->__val[-2]
#define b yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_block\n"));
  {
#line 1919
   __ = newBlock(b) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef s
#undef b
}
YY_ACTION(void) yy_1_block(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define s yy->__val[-2]
#define b yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_block\n"));
  {
#line 1918
   List_append(b, s) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef s
#undef b
}
YY_ACTION(void) yy_1_primdef(yycontext *yy, char *yytext, int yyleng)
{
#define p yy->__val[-1]
#define d yy->__val[-2]
#define t yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_primdef\n"));
  {
#line 1915
   __ = newPrimitive(d, t, p, 0) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef p
#undef d
#undef t
}
YY_ACTION(void) yy_2_funid(yycontext *yy, char *yytext, int yyleng)
{
#define d yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_funid\n"));
  {
#line 1911
   __ = d ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef d
}
YY_ACTION(void) yy_1_funid(yycontext *yy, char *yytext, int yyleng)
{
#define d yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_funid\n"));
  {
#line 1910
   __ = newTpointer(d) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef d
}
YY_ACTION(void) yy_1_fundefn(yycontext *yy, char *yytext, int yyleng)
{
#define b yy->__val[-1]
#define p yy->__val[-2]
#define d yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_fundefn\n"));
  {
#line 1908
   __ = newFunction(d, t, p, b) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef b
#undef p
#undef d
#undef t
}
YY_ACTION(void) yy_2_initelt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define u yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_initelt\n"));
  {
#line 1904
   __ = newAssign(newIndex (nil, i, t), e, u) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef u
#undef i
#undef t
}
YY_ACTION(void) yy_1_initelt(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define u yy->__val[-2]
#define i yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_initelt\n"));
  {
#line 1903
   __ = newAssign(newMember(nil, i, t), e, u) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef u
#undef i
#undef t
}
YY_ACTION(void) yy_3_agrinit(yycontext *yy, char *yytext, int yyleng)
{
#define j yy->__val[-1]
#define i yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_agrinit\n"));
  {
#line 1901
   __ = i ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef j
#undef i
}
YY_ACTION(void) yy_2_agrinit(yycontext *yy, char *yytext, int yyleng)
{
#define j yy->__val[-1]
#define i yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_agrinit\n"));
  {
#line 1900
   List_append(i, j) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef j
#undef i
}
YY_ACTION(void) yy_1_agrinit(yycontext *yy, char *yytext, int yyleng)
{
#define j yy->__val[-1]
#define i yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_agrinit\n"));
  {
#line 1899
   List_append(i, j) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef j
#undef i
}
YY_ACTION(void) yy_1_pdecl(yycontext *yy, char *yytext, int yyleng)
{
#define d yy->__val[-1]
#define t yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_pdecl\n"));
  {
#line 1894
   __ = newVariable(d, t, nil, 0) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef d
#undef t
}
YY_ACTION(void) yy_5_params(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define p yy->__val[-2]
#define a yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_params\n"));
  {
#line 1891
   expected(e, "parameter declaration") ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef p
#undef a
}
YY_ACTION(void) yy_4_params(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define p yy->__val[-2]
#define a yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_params\n"));
  {
#line 1890
   __ = a ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef p
#undef a
}
YY_ACTION(void) yy_3_params(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define p yy->__val[-2]
#define a yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_params\n"));
  {
#line 1889
   List_append(a, t_etc) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef p
#undef a
}
YY_ACTION(void) yy_2_params(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define p yy->__val[-2]
#define a yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_params\n"));
  {
#line 1888
   List_append(a, p) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef p
#undef a
}
YY_ACTION(void) yy_1_params(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define p yy->__val[-2]
#define a yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_params\n"));
  {
#line 1887
   List_append(a, p) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef p
#undef a
}
YY_ACTION(void) yy_3_ddector(yycontext *yy, char *yytext, int yyleng)
{
#define p yy->__val[-1]
#define e yy->__val[-2]
#define d yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_ddector\n"));
  {
#line 1884
   __ = d ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef p
#undef e
#undef d
}
YY_ACTION(void) yy_2_ddector(yycontext *yy, char *yytext, int yyleng)
{
#define p yy->__val[-1]
#define e yy->__val[-2]
#define d yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_ddector\n"));
  {
#line 1883
   d = newTfunction(d, vars2types(p)) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef p
#undef e
#undef d
}
YY_ACTION(void) yy_1_ddector(yycontext *yy, char *yytext, int yyleng)
{
#define p yy->__val[-1]
#define e yy->__val[-2]
#define d yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_ddector\n"));
  {
#line 1882
   d = newTarray(d, e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef p
#undef e
#undef d
}
YY_ACTION(void) yy_1_decltor(yycontext *yy, char *yytext, int yyleng)
{
#define d yy->__val[-1]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_decltor\n"));
  {
#line 1877
   __ = newTpointer(d) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef d
}
YY_ACTION(void) yy_3_inidecl(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define d yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_inidecl\n"));
  {
#line 1874
   __ = d ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef d
}
YY_ACTION(void) yy_2_inidecl(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define d yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_inidecl\n"));
  {
#line 1872
   expected(e, "variable initialiser") ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef d
}
YY_ACTION(void) yy_1_inidecl(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define t yy->__val[-2]
#define d yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_inidecl\n"));
  {
#line 1871
   __ = newAssign(d, e, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef t
#undef d
}
YY_ACTION(void) yy_3_members(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define v yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_members\n"));
  {
#line 1869
   __ = l ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef v
#undef l
}
YY_ACTION(void) yy_2_members(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define v yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_members\n"));
  {
#line 1868
   expected(e, "struct/union member specification") ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef v
#undef l
}
YY_ACTION(void) yy_1_members(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define v yy->__val[-2]
#define l yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_members\n"));
  {
#line 1866
   List_append(l, v) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef v
#undef l
}
YY_ACTION(void) yy_4_struct(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define m yy->__val[-2]
#define i yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_struct\n"));
  {
#line 1863
   expected(e, "structure/union definition") ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef m
#undef i
}
YY_ACTION(void) yy_3_struct(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define m yy->__val[-2]
#define i yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_struct\n"));
  {
#line 1862
   __ = newTstruct(nil,   m) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef m
#undef i
}
YY_ACTION(void) yy_2_struct(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define m yy->__val[-2]
#define i yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_struct\n"));
  {
#line 1861
   __ = newTstruct(  i, nil) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef m
#undef i
}
YY_ACTION(void) yy_1_struct(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define m yy->__val[-2]
#define i yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_struct\n"));
  {
#line 1860
   __ = newTstruct(  i,   m) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef m
#undef i
}
YY_ACTION(void) yy_7_tname(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_7_tname\n"));
  {
#line 1856
   __ = t_double ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_6_tname(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_6_tname\n"));
  {
#line 1855
   __ = t_float ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_5_tname(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_tname\n"));
  {
#line 1854
   __ = t_long ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_4_tname(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_tname\n"));
  {
#line 1853
   __ = t_int  ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_3_tname(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_tname\n"));
  {
#line 1852
   __ = t_short ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_2_tname(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_tname\n"));
  {
#line 1851
   __ = t_char ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_tname(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_tname\n"));
  {
#line 1850
   __ = t_void ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_3_vardecl(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define d yy->__val[-2]
#define t yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_vardecl\n"));
  {
#line 1848
   __ = d ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef d
#undef t
}
YY_ACTION(void) yy_2_vardecl(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define d yy->__val[-2]
#define t yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_vardecl\n"));
  {
#line 1847
   VarDecls_append(d, e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef d
#undef t
}
YY_ACTION(void) yy_1_vardecl(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define d yy->__val[-2]
#define t yy->__val[-3]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_vardecl\n"));
  {
#line 1846
   d = newVarDecls(t, d) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef d
#undef t
}
YY_ACTION(void) yy_3_typedec(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define d yy->__val[-2]
#define n yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_typedec\n"));
  {
#line 1844
   __ = d ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef d
#undef n
#undef t
}
YY_ACTION(void) yy_2_typedec(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define d yy->__val[-2]
#define n yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_typedec\n"));
  {
#line 1843
   TypeDecls_append(d, e) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef d
#undef n
#undef t
}
YY_ACTION(void) yy_1_typedec(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define d yy->__val[-2]
#define n yy->__val[-3]
#define t yy->__val[-4]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_typedec\n"));
  {
#line 1842
   d = newTypeDecls(n, d, t) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef d
#undef n
#undef t
}
YY_ACTION(void) yy_1_include(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_include\n"));
  {
#line 1837
   startInput(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_1_error(yycontext *yy, char *yytext, int yyleng)
{
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_error\n"));
  {
#line 1830
   __ = newStringWith(yytext) ;
  }
#undef yythunkpos
#undef yypos
#undef yy
}
YY_ACTION(void) yy_5_start(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_5_start\n"));
  {
#line 1826
   expected(e, "declaration") ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef x
}
YY_ACTION(void) yy_4_start(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_4_start\n"));
  {
#line 1825
   yysval = 0; endInput() ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef x
}
YY_ACTION(void) yy_3_start(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_3_start\n"));
  {
#line 1824
   yysval = x ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef x
}
YY_ACTION(void) yy_2_start(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_2_start\n"));
  {
#line 1823
   yysval = 0 ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef x
}
YY_ACTION(void) yy_1_start(yycontext *yy, char *yytext, int yyleng)
{
#define e yy->__val[-1]
#define x yy->__val[-2]
#define __ yy->__
#define yypos yy->__pos
#define yythunkpos yy->__thunkpos
  yyprintf((stderr, "do yy_1_start\n"));
  {
#line 1822
   yysval = 0 ;
  }
#undef yythunkpos
#undef yypos
#undef yy
#undef e
#undef x
}

YY_RULE(int) yy_comment(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "comment"));
  {  int yypos2= yy->__pos, yythunkpos2= yy->__thunkpos;  if (!yymatchString(yy, "//")) goto l3;
  l4:;	
  {  int yypos5= yy->__pos, yythunkpos5= yy->__thunkpos;
  {  int yypos6= yy->__pos, yythunkpos6= yy->__thunkpos;  if (!yy_eol(yy)) goto l6;  goto l5;
  l6:;	  yy->__pos= yypos6; yy->__thunkpos= yythunkpos6;
  }  if (!yymatchDot(yy)) goto l5;  goto l4;
  l5:;	  yy->__pos= yypos5; yy->__thunkpos= yythunkpos5;
  }  if (!yy_eol(yy)) goto l3;  goto l2;
  l3:;	  yy->__pos= yypos2; yy->__thunkpos= yythunkpos2;  if (!yymatchString(yy, "/*")) goto l1;
  l7:;	
  {  int yypos8= yy->__pos, yythunkpos8= yy->__thunkpos;
  {  int yypos9= yy->__pos, yythunkpos9= yy->__thunkpos;  if (!yymatchString(yy, "*/")) goto l9;  goto l8;
  l9:;	  yy->__pos= yypos9; yy->__thunkpos= yythunkpos9;
  }
  {  int yypos10= yy->__pos, yythunkpos10= yy->__thunkpos;  if (!yy_eol(yy)) goto l11;  goto l10;
  l11:;	  yy->__pos= yypos10; yy->__thunkpos= yythunkpos10;  if (!yymatchDot(yy)) goto l8;
  }
  l10:;	  goto l7;
  l8:;	  yy->__pos= yypos8; yy->__thunkpos= yythunkpos8;
  }  if (!yymatchString(yy, "*/")) goto l1;
  }
  l2:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "comment", yy->__buf+yy->__pos));
  return 1;
  l1:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "comment", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_space(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "space"));  if (!yymatchClass(yy, (unsigned char *)"\000\002\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l12;
  yyprintf((stderr, "  ok   %s @ %s\n", "space", yy->__buf+yy->__pos));
  return 1;
  l12:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "space", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_blank(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "blank"));
  {  int yypos14= yy->__pos, yythunkpos14= yy->__thunkpos;  if (!yy_space(yy)) goto l15;  goto l14;
  l15:;	  yy->__pos= yypos14; yy->__thunkpos= yythunkpos14;  if (!yy_eol(yy)) goto l16;  goto l14;
  l16:;	  yy->__pos= yypos14; yy->__thunkpos= yythunkpos14;  if (!yy_comment(yy)) goto l13;
  }
  l14:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "blank", yy->__buf+yy->__pos));
  return 1;
  l13:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "blank", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_STATIC(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "STATIC"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l17;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "static")) goto l17;
  {  int yypos18= yy->__pos, yythunkpos18= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l18;  goto l17;
  l18:;	  yy->__pos= yypos18; yy->__thunkpos= yythunkpos18;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l17;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_STATIC, yy->__begin, yy->__end);  if (!yy__(yy)) goto l17;
  yyprintf((stderr, "  ok   %s @ %s\n", "STATIC", yy->__buf+yy->__pos));
  return 1;
  l17:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "STATIC", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ENUM(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ENUM"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l19;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "enum")) goto l19;
  {  int yypos20= yy->__pos, yythunkpos20= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l20;  goto l19;
  l20:;	  yy->__pos= yypos20; yy->__thunkpos= yythunkpos20;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l19;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_ENUM, yy->__begin, yy->__end);  if (!yy__(yy)) goto l19;
  yyprintf((stderr, "  ok   %s @ %s\n", "ENUM", yy->__buf+yy->__pos));
  return 1;
  l19:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ENUM", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_UNION(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "UNION"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l21;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "union")) goto l21;
  {  int yypos22= yy->__pos, yythunkpos22= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l22;  goto l21;
  l22:;	  yy->__pos= yypos22; yy->__thunkpos= yythunkpos22;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l21;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_UNION, yy->__begin, yy->__end);  if (!yy__(yy)) goto l21;
  yyprintf((stderr, "  ok   %s @ %s\n", "UNION", yy->__buf+yy->__pos));
  return 1;
  l21:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "UNION", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_alnum(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "alnum"));  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l23;
  yyprintf((stderr, "  ok   %s @ %s\n", "alnum", yy->__buf+yy->__pos));
  return 1;
  l23:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "alnum", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_alpha(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "alpha"));  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\000\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l24;
  yyprintf((stderr, "  ok   %s @ %s\n", "alpha", yy->__buf+yy->__pos));
  return 1;
  l24:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "alpha", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_keyword(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "keyword"));
  {  int yypos26= yy->__pos, yythunkpos26= yy->__thunkpos;  if (!yy_TYPEDEF(yy)) goto l27;  goto l26;
  l27:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_VOID(yy)) goto l28;  goto l26;
  l28:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_CHAR(yy)) goto l29;  goto l26;
  l29:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_SHORT(yy)) goto l30;  goto l26;
  l30:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_INT(yy)) goto l31;  goto l26;
  l31:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_LONG(yy)) goto l32;  goto l26;
  l32:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_FLOAT(yy)) goto l33;  goto l26;
  l33:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_DOUBLE(yy)) goto l34;  goto l26;
  l34:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_STRUCT(yy)) goto l35;  goto l26;
  l35:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_UNION(yy)) goto l36;  goto l26;
  l36:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_ENUM(yy)) goto l37;  goto l26;
  l37:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_STATIC(yy)) goto l38;  goto l26;
  l38:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_EXTERN(yy)) goto l39;  goto l26;
  l39:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_IF(yy)) goto l40;  goto l26;
  l40:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_ELSE(yy)) goto l41;  goto l26;
  l41:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_WHILE(yy)) goto l42;  goto l26;
  l42:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_FOR(yy)) goto l43;  goto l26;
  l43:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_RETURN(yy)) goto l44;  goto l26;
  l44:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_CONTINU(yy)) goto l45;  goto l26;
  l45:;	  yy->__pos= yypos26; yy->__thunkpos= yythunkpos26;  if (!yy_BREAK(yy)) goto l25;
  }
  l26:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "keyword", yy->__buf+yy->__pos));
  return 1;
  l25:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "keyword", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_HEX(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "HEX"));  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\176\000\000\000\176\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l46;
  yyprintf((stderr, "  ok   %s @ %s\n", "HEX", yy->__buf+yy->__pos));
  return 1;
  l46:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "HEX", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_OCT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "OCT"));  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l47;
  yyprintf((stderr, "  ok   %s @ %s\n", "OCT", yy->__buf+yy->__pos));
  return 1;
  l47:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "OCT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_escaped(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "escaped"));
  {  int yypos49= yy->__pos, yythunkpos49= yy->__thunkpos;  if (!yymatchChar(yy, 'a')) goto l50;  yyDo(yy, yy_1_escaped, yy->__begin, yy->__end);  goto l49;
  l50:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 'b')) goto l51;  yyDo(yy, yy_2_escaped, yy->__begin, yy->__end);  goto l49;
  l51:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 'f')) goto l52;  yyDo(yy, yy_3_escaped, yy->__begin, yy->__end);  goto l49;
  l52:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 'n')) goto l53;  yyDo(yy, yy_4_escaped, yy->__begin, yy->__end);  goto l49;
  l53:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 'r')) goto l54;  yyDo(yy, yy_5_escaped, yy->__begin, yy->__end);  goto l49;
  l54:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 't')) goto l55;  yyDo(yy, yy_6_escaped, yy->__begin, yy->__end);  goto l49;
  l55:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 'v')) goto l56;  yyDo(yy, yy_7_escaped, yy->__begin, yy->__end);  goto l49;
  l56:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, '\'')) goto l57;  yyDo(yy, yy_8_escaped, yy->__begin, yy->__end);  goto l49;
  l57:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, '"')) goto l58;  yyDo(yy, yy_9_escaped, yy->__begin, yy->__end);  goto l49;
  l58:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, '\\')) goto l59;  yyDo(yy, yy_10_escaped, yy->__begin, yy->__end);  goto l49;
  l59:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l60;
#undef yytext
#undef yyleng
  }  if (!yy_OCT(yy)) goto l60;
  {  int yypos61= yy->__pos, yythunkpos61= yy->__thunkpos;  if (!yy_OCT(yy)) goto l61;  goto l62;
  l61:;	  yy->__pos= yypos61; yy->__thunkpos= yythunkpos61;
  }
  l62:;	
  {  int yypos63= yy->__pos, yythunkpos63= yy->__thunkpos;  if (!yy_OCT(yy)) goto l63;  goto l64;
  l63:;	  yy->__pos= yypos63; yy->__thunkpos= yythunkpos63;
  }
  l64:;	  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l60;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_11_escaped, yy->__begin, yy->__end);  goto l49;
  l60:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 'x')) goto l65;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l65;
#undef yytext
#undef yyleng
  }
  {  int yypos66= yy->__pos, yythunkpos66= yy->__thunkpos;  if (!yy_HEX(yy)) goto l66;  goto l67;
  l66:;	  yy->__pos= yypos66; yy->__thunkpos= yythunkpos66;
  }
  l67:;	
  {  int yypos68= yy->__pos, yythunkpos68= yy->__thunkpos;  if (!yy_HEX(yy)) goto l68;  goto l69;
  l68:;	  yy->__pos= yypos68; yy->__thunkpos= yythunkpos68;
  }
  l69:;	  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l65;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_12_escaped, yy->__begin, yy->__end);  goto l49;
  l65:;	  yy->__pos= yypos49; yy->__thunkpos= yythunkpos49;  if (!yymatchChar(yy, 'u')) goto l48;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l48;
#undef yytext
#undef yyleng
  }
  {  int yypos70= yy->__pos, yythunkpos70= yy->__thunkpos;  if (!yy_HEX(yy)) goto l70;  goto l71;
  l70:;	  yy->__pos= yypos70; yy->__thunkpos= yythunkpos70;
  }
  l71:;	
  {  int yypos72= yy->__pos, yythunkpos72= yy->__thunkpos;  if (!yy_HEX(yy)) goto l72;  goto l73;
  l72:;	  yy->__pos= yypos72; yy->__thunkpos= yythunkpos72;
  }
  l73:;	
  {  int yypos74= yy->__pos, yythunkpos74= yy->__thunkpos;  if (!yy_HEX(yy)) goto l74;  goto l75;
  l74:;	  yy->__pos= yypos74; yy->__thunkpos= yythunkpos74;
  }
  l75:;	
  {  int yypos76= yy->__pos, yythunkpos76= yy->__thunkpos;  if (!yy_HEX(yy)) goto l76;  goto l77;
  l76:;	  yy->__pos= yypos76; yy->__thunkpos= yythunkpos76;
  }
  l77:;	  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l48;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_13_escaped, yy->__begin, yy->__end);
  }
  l49:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "escaped", yy->__buf+yy->__pos));
  return 1;
  l48:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "escaped", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_mkStr(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "mkStr"));  yyDo(yy, yy_1_mkStr, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "mkStr", yy->__buf+yy->__pos));
  return 1;
  l78:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "mkStr", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_char(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "char"));
  {  int yypos80= yy->__pos, yythunkpos80= yy->__thunkpos;  if (!yymatchChar(yy, '\\')) goto l81;  if (!yy_escaped(yy)) goto l81;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_char, yy->__begin, yy->__end);  goto l80;
  l81:;	  yy->__pos= yypos80; yy->__thunkpos= yythunkpos80;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l79;
#undef yytext
#undef yyleng
  }  if (!yymatchDot(yy)) goto l79;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l79;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_2_char, yy->__begin, yy->__end);
  }
  l80:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "char", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l79:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "char", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_string(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "string"));  if (!yymatchChar(yy, '"')) goto l82;  if (!yy_mkStr(yy)) goto l82;  yyDo(yy, yySet, -2, 0);
  l83:;	
  {  int yypos84= yy->__pos, yythunkpos84= yy->__thunkpos;
  {  int yypos85= yy->__pos, yythunkpos85= yy->__thunkpos;  if (!yymatchChar(yy, '"')) goto l85;  goto l84;
  l85:;	  yy->__pos= yypos85; yy->__thunkpos= yythunkpos85;
  }  if (!yy_char(yy)) goto l84;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_string, yy->__begin, yy->__end);  goto l83;
  l84:;	  yy->__pos= yypos84; yy->__thunkpos= yythunkpos84;
  }  if (!yymatchChar(yy, '"')) goto l82;  if (!yy__(yy)) goto l82;  yyDo(yy, yy_2_string, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "string", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l82:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "string", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_integer(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "integer"));
  {  int yypos87= yy->__pos, yythunkpos87= yy->__thunkpos;  if (!yymatchString(yy, "0x")) goto l88;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l88;
#undef yytext
#undef yyleng
  }  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\176\000\000\000\176\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l88;
  l89:;	
  {  int yypos90= yy->__pos, yythunkpos90= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\176\000\000\000\176\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l90;  goto l89;
  l90:;	  yy->__pos= yypos90; yy->__thunkpos= yythunkpos90;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l88;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l88;  yyDo(yy, yy_1_integer, yy->__begin, yy->__end);  goto l87;
  l88:;	  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;  if (!yymatchString(yy, "0b")) goto l91;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l91;
#undef yytext
#undef yyleng
  }  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l91;
  l92:;	
  {  int yypos93= yy->__pos, yythunkpos93= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l93;  goto l92;
  l93:;	  yy->__pos= yypos93; yy->__thunkpos= yythunkpos93;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l91;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l91;  yyDo(yy, yy_2_integer, yy->__begin, yy->__end);  goto l87;
  l91:;	  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l94;
#undef yytext
#undef yyleng
  }  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l94;
  l95:;	
  {  int yypos96= yy->__pos, yythunkpos96= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l96;  goto l95;
  l96:;	  yy->__pos= yypos96; yy->__thunkpos= yythunkpos96;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l94;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l94;  yyDo(yy, yy_3_integer, yy->__begin, yy->__end);  goto l87;
  l94:;	  yy->__pos= yypos87; yy->__thunkpos= yythunkpos87;  if (!yymatchChar(yy, '\'')) goto l86;
  {  int yypos97= yy->__pos, yythunkpos97= yy->__thunkpos;  if (!yymatchChar(yy, '\'')) goto l97;  goto l86;
  l97:;	  yy->__pos= yypos97; yy->__thunkpos= yythunkpos97;
  }  if (!yy_char(yy)) goto l86;  yyDo(yy, yySet, -1, 0);  if (!yymatchChar(yy, '\'')) goto l86;  if (!yy__(yy)) goto l86;  yyDo(yy, yy_4_integer, yy->__begin, yy->__end);
  }
  l87:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "integer", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l86:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "integer", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_float(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "float"));
  {  int yypos99= yy->__pos, yythunkpos99= yy->__thunkpos;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l100;
#undef yytext
#undef yyleng
  }
  {  int yypos101= yy->__pos, yythunkpos101= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l101;  goto l102;
  l101:;	  yy->__pos= yypos101; yy->__thunkpos= yythunkpos101;
  }
  l102:;	
  l103:;	
  {  int yypos104= yy->__pos, yythunkpos104= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l104;  goto l103;
  l104:;	  yy->__pos= yypos104; yy->__thunkpos= yythunkpos104;
  }  if (!yymatchChar(yy, '.')) goto l100;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l100;
  l105:;	
  {  int yypos106= yy->__pos, yythunkpos106= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l106;  goto l105;
  l106:;	  yy->__pos= yypos106; yy->__thunkpos= yythunkpos106;
  }
  {  int yypos107= yy->__pos, yythunkpos107= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\000\040\000\000\000\040\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l107;
  {  int yypos109= yy->__pos, yythunkpos109= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l109;  goto l110;
  l109:;	  yy->__pos= yypos109; yy->__thunkpos= yythunkpos109;
  }
  l110:;	  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l107;
  l111:;	
  {  int yypos112= yy->__pos, yythunkpos112= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l112;  goto l111;
  l112:;	  yy->__pos= yypos112; yy->__thunkpos= yythunkpos112;
  }  goto l108;
  l107:;	  yy->__pos= yypos107; yy->__thunkpos= yythunkpos107;
  }
  l108:;	  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l100;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l100;  yyDo(yy, yy_1_float, yy->__begin, yy->__end);  goto l99;
  l100:;	  yy->__pos= yypos99; yy->__thunkpos= yythunkpos99;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l113;
#undef yytext
#undef yyleng
  }
  {  int yypos114= yy->__pos, yythunkpos114= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l114;  goto l115;
  l114:;	  yy->__pos= yypos114; yy->__thunkpos= yythunkpos114;
  }
  l115:;	  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l113;
  l116:;	
  {  int yypos117= yy->__pos, yythunkpos117= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l117;  goto l116;
  l117:;	  yy->__pos= yypos117; yy->__thunkpos= yythunkpos117;
  }  if (!yymatchChar(yy, '.')) goto l113;
  l118:;	
  {  int yypos119= yy->__pos, yythunkpos119= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l119;  goto l118;
  l119:;	  yy->__pos= yypos119; yy->__thunkpos= yythunkpos119;
  }
  {  int yypos120= yy->__pos, yythunkpos120= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\000\040\000\000\000\040\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l120;
  {  int yypos122= yy->__pos, yythunkpos122= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l122;  goto l123;
  l122:;	  yy->__pos= yypos122; yy->__thunkpos= yythunkpos122;
  }
  l123:;	  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l120;
  l124:;	
  {  int yypos125= yy->__pos, yythunkpos125= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l125;  goto l124;
  l125:;	  yy->__pos= yypos125; yy->__thunkpos= yythunkpos125;
  }  goto l121;
  l120:;	  yy->__pos= yypos120; yy->__thunkpos= yythunkpos120;
  }
  l121:;	  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l113;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l113;  yyDo(yy, yy_2_float, yy->__begin, yy->__end);  goto l99;
  l113:;	  yy->__pos= yypos99; yy->__thunkpos= yythunkpos99;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l98;
#undef yytext
#undef yyleng
  }
  {  int yypos126= yy->__pos, yythunkpos126= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l126;  goto l127;
  l126:;	  yy->__pos= yypos126; yy->__thunkpos= yythunkpos126;
  }
  l127:;	  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l98;
  l128:;	
  {  int yypos129= yy->__pos, yythunkpos129= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l129;  goto l128;
  l129:;	  yy->__pos= yypos129; yy->__thunkpos= yythunkpos129;
  }
  {  int yypos130= yy->__pos, yythunkpos130= yy->__thunkpos;  if (!yymatchChar(yy, '.')) goto l130;  goto l131;
  l130:;	  yy->__pos= yypos130; yy->__thunkpos= yythunkpos130;
  }
  l131:;	
  l132:;	
  {  int yypos133= yy->__pos, yythunkpos133= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l133;  goto l132;
  l133:;	  yy->__pos= yypos133; yy->__thunkpos= yythunkpos133;
  }  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\000\040\000\000\000\040\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l98;
  {  int yypos134= yy->__pos, yythunkpos134= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\050\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l134;  goto l135;
  l134:;	  yy->__pos= yypos134; yy->__thunkpos= yythunkpos134;
  }
  l135:;	  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l98;
  l136:;	
  {  int yypos137= yy->__pos, yythunkpos137= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l137;  goto l136;
  l137:;	  yy->__pos= yypos137; yy->__thunkpos= yythunkpos137;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l98;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l98;  yyDo(yy, yy_3_float, yy->__begin, yy->__end);
  }
  l99:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "float", yy->__buf+yy->__pos));
  return 1;
  l98:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "float", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ARROW(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ARROW"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l138;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "->")) goto l138;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l138;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_ARROW, yy->__begin, yy->__end);  if (!yy__(yy)) goto l138;
  yyprintf((stderr, "  ok   %s @ %s\n", "ARROW", yy->__buf+yy->__pos));
  return 1;
  l138:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ARROW", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_args(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "args"));  if (!yy_mkList(yy)) goto l139;  yyDo(yy, yySet, -2, 0);
  {  int yypos140= yy->__pos, yythunkpos140= yy->__thunkpos;  if (!yy_expr(yy)) goto l140;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_args, yy->__begin, yy->__end);
  l142:;	
  {  int yypos143= yy->__pos, yythunkpos143= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l143;  if (!yy_expr(yy)) goto l143;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_args, yy->__begin, yy->__end);  goto l142;
  l143:;	  yy->__pos= yypos143; yy->__thunkpos= yythunkpos143;
  }  goto l141;
  l140:;	  yy->__pos= yypos140; yy->__thunkpos= yythunkpos140;
  }
  l141:;	  yyDo(yy, yy_3_args, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "args", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l139:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "args", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_value(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "value"));
  {  int yypos145= yy->__pos, yythunkpos145= yy->__thunkpos;  if (!yy_LPAREN(yy)) goto l146;  if (!yy_expr(yy)) goto l146;  yyDo(yy, yySet, -1, 0);  if (!yy_RPAREN(yy)) goto l146;  yyDo(yy, yy_1_value, yy->__begin, yy->__end);  goto l145;
  l146:;	  yy->__pos= yypos145; yy->__thunkpos= yythunkpos145;  if (!yy_float(yy)) goto l147;  goto l145;
  l147:;	  yy->__pos= yypos145; yy->__thunkpos= yythunkpos145;  if (!yy_integer(yy)) goto l148;  goto l145;
  l148:;	  yy->__pos= yypos145; yy->__thunkpos= yythunkpos145;  if (!yy_string(yy)) goto l149;  goto l145;
  l149:;	  yy->__pos= yypos145; yy->__thunkpos= yythunkpos145;  if (!yy_id(yy)) goto l144;
  }
  l145:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "value", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l144:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "value", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_postfix(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 4, 0);
  yyprintf((stderr, "%s\n", "postfix"));  if (!yy_value(yy)) goto l150;  yyDo(yy, yySet, -4, 0);
  l151:;	
  {  int yypos152= yy->__pos, yythunkpos152= yy->__thunkpos;
  {  int yypos153= yy->__pos, yythunkpos153= yy->__thunkpos;  if (!yy_LPAREN(yy)) goto l154;  yyDo(yy, yySet, -3, 0);  if (!yy_args(yy)) goto l154;  yyDo(yy, yySet, -2, 0);  if (!yy_RPAREN(yy)) goto l154;  yyDo(yy, yy_1_postfix, yy->__begin, yy->__end);  goto l153;
  l154:;	  yy->__pos= yypos153; yy->__thunkpos= yythunkpos153;  if (!yy_LBRAK(yy)) goto l155;  yyDo(yy, yySet, -3, 0);  if (!yy_expr(yy)) goto l155;  yyDo(yy, yySet, -1, 0);  if (!yy_RBRAK(yy)) goto l155;  yyDo(yy, yy_2_postfix, yy->__begin, yy->__end);  goto l153;
  l155:;	  yy->__pos= yypos153; yy->__thunkpos= yythunkpos153;  if (!yy_PPLUS(yy)) goto l156;  yyDo(yy, yySet, -3, 0);  yyDo(yy, yy_3_postfix, yy->__begin, yy->__end);  goto l153;
  l156:;	  yy->__pos= yypos153; yy->__thunkpos= yythunkpos153;  if (!yy_MMINUS(yy)) goto l157;  yyDo(yy, yySet, -3, 0);  yyDo(yy, yy_4_postfix, yy->__begin, yy->__end);  goto l153;
  l157:;	  yy->__pos= yypos153; yy->__thunkpos= yythunkpos153;  if (!yy_DOT(yy)) goto l158;  yyDo(yy, yySet, -3, 0);  if (!yy_id(yy)) goto l158;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_5_postfix, yy->__begin, yy->__end);  goto l153;
  l158:;	  yy->__pos= yypos153; yy->__thunkpos= yythunkpos153;  if (!yy_ARROW(yy)) goto l152;  yyDo(yy, yySet, -3, 0);  if (!yy_id(yy)) goto l152;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_6_postfix, yy->__begin, yy->__end);
  }
  l153:;	  goto l151;
  l152:;	  yy->__pos= yypos152; yy->__thunkpos= yythunkpos152;
  }  yyDo(yy, yy_7_postfix, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "postfix", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 4, 0);
  return 1;
  l150:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "postfix", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_cast(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "cast"));  if (!yy_LPAREN(yy)) goto l159;  if (!yy_tnamdec(yy)) goto l159;  yyDo(yy, yySet, -2, 0);  if (!yy_RPAREN(yy)) goto l159;  if (!yy_unary(yy)) goto l159;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_cast, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "cast", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l159:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "cast", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_tnamdec(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "tnamdec"));  if (!yy_tname(yy)) goto l160;  yyDo(yy, yySet, -2, 0);  if (!yy_decltor(yy)) goto l160;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_tnamdec, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "tnamdec", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l160:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "tnamdec", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_SIZEOF(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "SIZEOF"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l161;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "sizeof")) goto l161;
  {  int yypos162= yy->__pos, yythunkpos162= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l162;  goto l161;
  l162:;	  yy->__pos= yypos162; yy->__thunkpos= yythunkpos162;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l161;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_SIZEOF, yy->__begin, yy->__end);  if (!yy__(yy)) goto l161;
  yyprintf((stderr, "  ok   %s @ %s\n", "SIZEOF", yy->__buf+yy->__pos));
  return 1;
  l161:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "SIZEOF", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_MMINUS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MMINUS"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l163;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "--")) goto l163;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l163;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_MMINUS, yy->__begin, yy->__end);  if (!yy__(yy)) goto l163;
  yyprintf((stderr, "  ok   %s @ %s\n", "MMINUS", yy->__buf+yy->__pos));
  return 1;
  l163:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MMINUS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_PPLUS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PPLUS"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l164;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "++")) goto l164;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l164;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_PPLUS, yy->__begin, yy->__end);  if (!yy__(yy)) goto l164;
  yyprintf((stderr, "  ok   %s @ %s\n", "PPLUS", yy->__buf+yy->__pos));
  return 1;
  l164:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PPLUS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_TILDE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "TILDE"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l165;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '~')) goto l165;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l165;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_TILDE, yy->__begin, yy->__end);  if (!yy__(yy)) goto l165;
  yyprintf((stderr, "  ok   %s @ %s\n", "TILDE", yy->__buf+yy->__pos));
  return 1;
  l165:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "TILDE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_PLING(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PLING"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l166;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '!')) goto l166;
  {  int yypos167= yy->__pos, yythunkpos167= yy->__thunkpos;  if (!yymatchChar(yy, '=')) goto l167;  goto l166;
  l167:;	  yy->__pos= yypos167; yy->__thunkpos= yythunkpos167;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l166;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_PLING, yy->__begin, yy->__end);  if (!yy__(yy)) goto l166;
  yyprintf((stderr, "  ok   %s @ %s\n", "PLING", yy->__buf+yy->__pos));
  return 1;
  l166:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PLING", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_PCENT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PCENT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l168;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '%')) goto l168;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l168;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_PCENT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l168;
  yyprintf((stderr, "  ok   %s @ %s\n", "PCENT", yy->__buf+yy->__pos));
  return 1;
  l168:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PCENT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_SLASH(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "SLASH"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l169;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '/')) goto l169;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l169;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_SLASH, yy->__begin, yy->__end);  if (!yy__(yy)) goto l169;
  yyprintf((stderr, "  ok   %s @ %s\n", "SLASH", yy->__buf+yy->__pos));
  return 1;
  l169:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "SLASH", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_MINUS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "MINUS"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l170;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '-')) goto l170;
  {  int yypos171= yy->__pos, yythunkpos171= yy->__thunkpos;  if (!yymatchChar(yy, '-')) goto l171;  goto l170;
  l171:;	  yy->__pos= yypos171; yy->__thunkpos= yythunkpos171;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l170;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_MINUS, yy->__begin, yy->__end);  if (!yy__(yy)) goto l170;
  yyprintf((stderr, "  ok   %s @ %s\n", "MINUS", yy->__buf+yy->__pos));
  return 1;
  l170:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "MINUS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_PLUS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "PLUS"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l172;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '+')) goto l172;
  {  int yypos173= yy->__pos, yythunkpos173= yy->__thunkpos;  if (!yymatchChar(yy, '+')) goto l173;  goto l172;
  l173:;	  yy->__pos= yypos173; yy->__thunkpos= yythunkpos173;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l172;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_PLUS, yy->__begin, yy->__end);  if (!yy__(yy)) goto l172;
  yyprintf((stderr, "  ok   %s @ %s\n", "PLUS", yy->__buf+yy->__pos));
  return 1;
  l172:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "PLUS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_prod(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "prod"));  if (!yy_unary(yy)) goto l174;  yyDo(yy, yySet, -3, 0);
  l175:;	
  {  int yypos176= yy->__pos, yythunkpos176= yy->__thunkpos;
  {  int yypos177= yy->__pos, yythunkpos177= yy->__thunkpos;  if (!yy_STAR(yy)) goto l178;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l178;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_prod, yy->__begin, yy->__end);  goto l177;
  l178:;	  yy->__pos= yypos177; yy->__thunkpos= yythunkpos177;  if (!yy_SLASH(yy)) goto l179;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l179;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_prod, yy->__begin, yy->__end);  goto l177;
  l179:;	  yy->__pos= yypos177; yy->__thunkpos= yythunkpos177;  if (!yy_PCENT(yy)) goto l176;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l176;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_3_prod, yy->__begin, yy->__end);
  }
  l177:;	  goto l175;
  l176:;	  yy->__pos= yypos176; yy->__thunkpos= yythunkpos176;
  }  yyDo(yy, yy_4_prod, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "prod", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l174:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "prod", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RSHIFT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RSHIFT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l180;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, ">>")) goto l180;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l180;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_RSHIFT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l180;
  yyprintf((stderr, "  ok   %s @ %s\n", "RSHIFT", yy->__buf+yy->__pos));
  return 1;
  l180:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RSHIFT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LSHIFT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LSHIFT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l181;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "<<")) goto l181;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l181;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_LSHIFT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l181;
  yyprintf((stderr, "  ok   %s @ %s\n", "LSHIFT", yy->__buf+yy->__pos));
  return 1;
  l181:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LSHIFT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_sum(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "sum"));  if (!yy_prod(yy)) goto l182;  yyDo(yy, yySet, -3, 0);
  l183:;	
  {  int yypos184= yy->__pos, yythunkpos184= yy->__thunkpos;
  {  int yypos185= yy->__pos, yythunkpos185= yy->__thunkpos;  if (!yy_PLUS(yy)) goto l186;  yyDo(yy, yySet, -2, 0);  if (!yy_prod(yy)) goto l186;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_sum, yy->__begin, yy->__end);  goto l185;
  l186:;	  yy->__pos= yypos185; yy->__thunkpos= yythunkpos185;  if (!yy_MINUS(yy)) goto l184;  yyDo(yy, yySet, -2, 0);  if (!yy_prod(yy)) goto l184;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_sum, yy->__begin, yy->__end);
  }
  l185:;	  goto l183;
  l184:;	  yy->__pos= yypos184; yy->__thunkpos= yythunkpos184;
  }  yyDo(yy, yy_3_sum, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "sum", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l182:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "sum", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_GRTR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "GRTR"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l187;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '>')) goto l187;
  {  int yypos188= yy->__pos, yythunkpos188= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\140\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l188;  goto l187;
  l188:;	  yy->__pos= yypos188; yy->__thunkpos= yythunkpos188;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l187;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_GRTR, yy->__begin, yy->__end);  if (!yy__(yy)) goto l187;
  yyprintf((stderr, "  ok   %s @ %s\n", "GRTR", yy->__buf+yy->__pos));
  return 1;
  l187:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "GRTR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_GRTREQ(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "GRTREQ"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l189;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, ">=")) goto l189;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l189;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_GRTREQ, yy->__begin, yy->__end);  if (!yy__(yy)) goto l189;
  yyprintf((stderr, "  ok   %s @ %s\n", "GRTREQ", yy->__buf+yy->__pos));
  return 1;
  l189:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "GRTREQ", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LESSEQ(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LESSEQ"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l190;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "<=")) goto l190;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l190;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_LESSEQ, yy->__begin, yy->__end);  if (!yy__(yy)) goto l190;
  yyprintf((stderr, "  ok   %s @ %s\n", "LESSEQ", yy->__buf+yy->__pos));
  return 1;
  l190:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LESSEQ", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LESS(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LESS"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l191;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '<')) goto l191;
  {  int yypos192= yy->__pos, yythunkpos192= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\000\060\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l192;  goto l191;
  l192:;	  yy->__pos= yypos192; yy->__thunkpos= yythunkpos192;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l191;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_LESS, yy->__begin, yy->__end);  if (!yy__(yy)) goto l191;
  yyprintf((stderr, "  ok   %s @ %s\n", "LESS", yy->__buf+yy->__pos));
  return 1;
  l191:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LESS", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_shift(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "shift"));  if (!yy_sum(yy)) goto l193;  yyDo(yy, yySet, -3, 0);
  l194:;	
  {  int yypos195= yy->__pos, yythunkpos195= yy->__thunkpos;
  {  int yypos196= yy->__pos, yythunkpos196= yy->__thunkpos;  if (!yy_LSHIFT(yy)) goto l197;  yyDo(yy, yySet, -2, 0);  if (!yy_sum(yy)) goto l197;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_shift, yy->__begin, yy->__end);  goto l196;
  l197:;	  yy->__pos= yypos196; yy->__thunkpos= yythunkpos196;  if (!yy_RSHIFT(yy)) goto l195;  yyDo(yy, yySet, -2, 0);  if (!yy_sum(yy)) goto l195;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_shift, yy->__begin, yy->__end);
  }
  l196:;	  goto l194;
  l195:;	  yy->__pos= yypos195; yy->__thunkpos= yythunkpos195;
  }  yyDo(yy, yy_3_shift, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "shift", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l193:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "shift", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_NEQUAL(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "NEQUAL"));  if (!yymatchString(yy, "!=")) goto l198;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l198;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_NEQUAL, yy->__begin, yy->__end);  if (!yy__(yy)) goto l198;
  yyprintf((stderr, "  ok   %s @ %s\n", "NEQUAL", yy->__buf+yy->__pos));
  return 1;
  l198:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "NEQUAL", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_EQUAL(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "EQUAL"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l199;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "==")) goto l199;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l199;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_EQUAL, yy->__begin, yy->__end);  if (!yy__(yy)) goto l199;
  yyprintf((stderr, "  ok   %s @ %s\n", "EQUAL", yy->__buf+yy->__pos));
  return 1;
  l199:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "EQUAL", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_inequal(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "inequal"));  if (!yy_shift(yy)) goto l200;  yyDo(yy, yySet, -3, 0);
  l201:;	
  {  int yypos202= yy->__pos, yythunkpos202= yy->__thunkpos;
  {  int yypos203= yy->__pos, yythunkpos203= yy->__thunkpos;  if (!yy_LESS(yy)) goto l204;  yyDo(yy, yySet, -2, 0);  if (!yy_shift(yy)) goto l204;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_inequal, yy->__begin, yy->__end);  goto l203;
  l204:;	  yy->__pos= yypos203; yy->__thunkpos= yythunkpos203;  if (!yy_LESSEQ(yy)) goto l205;  yyDo(yy, yySet, -2, 0);  if (!yy_shift(yy)) goto l205;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_inequal, yy->__begin, yy->__end);  goto l203;
  l205:;	  yy->__pos= yypos203; yy->__thunkpos= yythunkpos203;  if (!yy_GRTREQ(yy)) goto l206;  yyDo(yy, yySet, -2, 0);  if (!yy_shift(yy)) goto l206;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_3_inequal, yy->__begin, yy->__end);  goto l203;
  l206:;	  yy->__pos= yypos203; yy->__thunkpos= yythunkpos203;  if (!yy_GRTR(yy)) goto l202;  yyDo(yy, yySet, -2, 0);  if (!yy_shift(yy)) goto l202;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_4_inequal, yy->__begin, yy->__end);
  }
  l203:;	  goto l201;
  l202:;	  yy->__pos= yypos202; yy->__thunkpos= yythunkpos202;
  }  yyDo(yy, yy_5_inequal, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "inequal", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l200:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "inequal", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_AND(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "AND"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l207;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '&')) goto l207;
  {  int yypos208= yy->__pos, yythunkpos208= yy->__thunkpos;  if (!yymatchChar(yy, '&')) goto l208;  goto l207;
  l208:;	  yy->__pos= yypos208; yy->__thunkpos= yythunkpos208;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l207;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_AND, yy->__begin, yy->__end);  if (!yy__(yy)) goto l207;
  yyprintf((stderr, "  ok   %s @ %s\n", "AND", yy->__buf+yy->__pos));
  return 1;
  l207:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "AND", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_equal(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "equal"));  if (!yy_inequal(yy)) goto l209;  yyDo(yy, yySet, -3, 0);
  l210:;	
  {  int yypos211= yy->__pos, yythunkpos211= yy->__thunkpos;
  {  int yypos212= yy->__pos, yythunkpos212= yy->__thunkpos;  if (!yy_EQUAL(yy)) goto l213;  yyDo(yy, yySet, -2, 0);  if (!yy_inequal(yy)) goto l213;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_equal, yy->__begin, yy->__end);  goto l212;
  l213:;	  yy->__pos= yypos212; yy->__thunkpos= yythunkpos212;  if (!yy_NEQUAL(yy)) goto l211;  yyDo(yy, yySet, -2, 0);  if (!yy_inequal(yy)) goto l211;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_equal, yy->__begin, yy->__end);
  }
  l212:;	  goto l210;
  l211:;	  yy->__pos= yypos211; yy->__thunkpos= yythunkpos211;
  }  yyDo(yy, yy_3_equal, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "equal", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l209:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "equal", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_HAT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "HAT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l214;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '^')) goto l214;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l214;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_HAT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l214;
  yyprintf((stderr, "  ok   %s @ %s\n", "HAT", yy->__buf+yy->__pos));
  return 1;
  l214:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "HAT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_bitand(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "bitand"));  if (!yy_equal(yy)) goto l215;  yyDo(yy, yySet, -3, 0);
  l216:;	
  {  int yypos217= yy->__pos, yythunkpos217= yy->__thunkpos;  if (!yy_AND(yy)) goto l217;  yyDo(yy, yySet, -2, 0);  if (!yy_equal(yy)) goto l217;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_bitand, yy->__begin, yy->__end);  goto l216;
  l217:;	  yy->__pos= yypos217; yy->__thunkpos= yythunkpos217;
  }  yyDo(yy, yy_2_bitand, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "bitand", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l215:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "bitand", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_BAR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "BAR"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l218;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '|')) goto l218;
  {  int yypos219= yy->__pos, yythunkpos219= yy->__thunkpos;  if (!yymatchChar(yy, '|')) goto l219;  goto l218;
  l219:;	  yy->__pos= yypos219; yy->__thunkpos= yythunkpos219;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l218;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_BAR, yy->__begin, yy->__end);  if (!yy__(yy)) goto l218;
  yyprintf((stderr, "  ok   %s @ %s\n", "BAR", yy->__buf+yy->__pos));
  return 1;
  l218:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "BAR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_bitxor(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "bitxor"));  if (!yy_bitand(yy)) goto l220;  yyDo(yy, yySet, -3, 0);
  l221:;	
  {  int yypos222= yy->__pos, yythunkpos222= yy->__thunkpos;  if (!yy_HAT(yy)) goto l222;  yyDo(yy, yySet, -2, 0);  if (!yy_bitand(yy)) goto l222;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_bitxor, yy->__begin, yy->__end);  goto l221;
  l222:;	  yy->__pos= yypos222; yy->__thunkpos= yythunkpos222;
  }  yyDo(yy, yy_2_bitxor, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "bitxor", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l220:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "bitxor", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ANDAND(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ANDAND"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l223;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "&&")) goto l223;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l223;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_ANDAND, yy->__begin, yy->__end);  if (!yy__(yy)) goto l223;
  yyprintf((stderr, "  ok   %s @ %s\n", "ANDAND", yy->__buf+yy->__pos));
  return 1;
  l223:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ANDAND", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_bitor(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "bitor"));  if (!yy_bitxor(yy)) goto l224;  yyDo(yy, yySet, -3, 0);
  l225:;	
  {  int yypos226= yy->__pos, yythunkpos226= yy->__thunkpos;  if (!yy_BAR(yy)) goto l226;  yyDo(yy, yySet, -2, 0);  if (!yy_bitxor(yy)) goto l226;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_bitor, yy->__begin, yy->__end);  goto l225;
  l226:;	  yy->__pos= yypos226; yy->__thunkpos= yythunkpos226;
  }  yyDo(yy, yy_2_bitor, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "bitor", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l224:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "bitor", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_BARBAR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "BARBAR"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l227;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "||")) goto l227;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l227;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_BARBAR, yy->__begin, yy->__end);  if (!yy__(yy)) goto l227;
  yyprintf((stderr, "  ok   %s @ %s\n", "BARBAR", yy->__buf+yy->__pos));
  return 1;
  l227:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "BARBAR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_logand(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "logand"));  if (!yy_bitor(yy)) goto l228;  yyDo(yy, yySet, -3, 0);
  l229:;	
  {  int yypos230= yy->__pos, yythunkpos230= yy->__thunkpos;  if (!yy_ANDAND(yy)) goto l230;  yyDo(yy, yySet, -2, 0);  if (!yy_bitor(yy)) goto l230;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_logand, yy->__begin, yy->__end);  goto l229;
  l230:;	  yy->__pos= yypos230; yy->__thunkpos= yythunkpos230;
  }  yyDo(yy, yy_2_logand, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "logand", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l228:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "logand", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_logor(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "logor"));  if (!yy_logand(yy)) goto l231;  yyDo(yy, yySet, -3, 0);
  l232:;	
  {  int yypos233= yy->__pos, yythunkpos233= yy->__thunkpos;  if (!yy_BARBAR(yy)) goto l233;  yyDo(yy, yySet, -2, 0);  if (!yy_logand(yy)) goto l233;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_logor, yy->__begin, yy->__end);  goto l232;
  l233:;	  yy->__pos= yypos233; yy->__thunkpos= yythunkpos233;
  }  yyDo(yy, yy_2_logor, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "logor", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l231:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "logor", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_unary(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "unary"));
  {  int yypos235= yy->__pos, yythunkpos235= yy->__thunkpos;  if (!yy_MINUS(yy)) goto l236;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l236;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_unary, yy->__begin, yy->__end);  goto l235;
  l236:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_PLING(yy)) goto l237;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l237;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_unary, yy->__begin, yy->__end);  goto l235;
  l237:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_TILDE(yy)) goto l238;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l238;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_3_unary, yy->__begin, yy->__end);  goto l235;
  l238:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_STAR(yy)) goto l239;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l239;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_4_unary, yy->__begin, yy->__end);  goto l235;
  l239:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_AND(yy)) goto l240;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l240;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_5_unary, yy->__begin, yy->__end);  goto l235;
  l240:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_PPLUS(yy)) goto l241;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l241;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_6_unary, yy->__begin, yy->__end);  goto l235;
  l241:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_MMINUS(yy)) goto l242;  yyDo(yy, yySet, -2, 0);  if (!yy_unary(yy)) goto l242;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_7_unary, yy->__begin, yy->__end);  goto l235;
  l242:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_SIZEOF(yy)) goto l243;  yyDo(yy, yySet, -2, 0);
  {  int yypos244= yy->__pos, yythunkpos244= yy->__thunkpos;  if (!yy_unary(yy)) goto l245;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_8_unary, yy->__begin, yy->__end);  goto l244;
  l245:;	  yy->__pos= yypos244; yy->__thunkpos= yythunkpos244;  if (!yy_LPAREN(yy)) goto l243;  if (!yy_tnamdec(yy)) goto l243;  yyDo(yy, yySet, -1, 0);  if (!yy_RPAREN(yy)) goto l243;  yyDo(yy, yy_9_unary, yy->__begin, yy->__end);
  }
  l244:;	  goto l235;
  l243:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_cast(yy)) goto l246;  goto l235;
  l246:;	  yy->__pos= yypos235; yy->__thunkpos= yythunkpos235;  if (!yy_postfix(yy)) goto l234;
  }
  l235:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "unary", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l234:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "unary", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_assign(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "assign"));
  {  int yypos248= yy->__pos, yythunkpos248= yy->__thunkpos;  if (!yy_unary(yy)) goto l249;  yyDo(yy, yySet, -3, 0);  if (!yy_ASSIGN(yy)) goto l249;  yyDo(yy, yySet, -2, 0);  if (!yy_expr(yy)) goto l249;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_assign, yy->__begin, yy->__end);  goto l248;
  l249:;	  yy->__pos= yypos248; yy->__thunkpos= yythunkpos248;  if (!yy_logor(yy)) goto l247;
  }
  l248:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "assign", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l247:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "assign", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_BREAK(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "BREAK"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l250;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "break")) goto l250;
  {  int yypos251= yy->__pos, yythunkpos251= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l251;  goto l250;
  l251:;	  yy->__pos= yypos251; yy->__thunkpos= yythunkpos251;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l250;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_BREAK, yy->__begin, yy->__end);  if (!yy__(yy)) goto l250;
  yyprintf((stderr, "  ok   %s @ %s\n", "BREAK", yy->__buf+yy->__pos));
  return 1;
  l250:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "BREAK", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_CONTINU(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "CONTINU"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l252;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "continue")) goto l252;
  {  int yypos253= yy->__pos, yythunkpos253= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l253;  goto l252;
  l253:;	  yy->__pos= yypos253; yy->__thunkpos= yythunkpos253;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l252;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_CONTINU, yy->__begin, yy->__end);  if (!yy__(yy)) goto l252;
  yyprintf((stderr, "  ok   %s @ %s\n", "CONTINU", yy->__buf+yy->__pos));
  return 1;
  l252:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "CONTINU", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RETURN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RETURN"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l254;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "return")) goto l254;
  {  int yypos255= yy->__pos, yythunkpos255= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l255;  goto l254;
  l255:;	  yy->__pos= yypos255; yy->__thunkpos= yythunkpos255;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l254;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_RETURN, yy->__begin, yy->__end);  if (!yy__(yy)) goto l254;
  yyprintf((stderr, "  ok   %s @ %s\n", "RETURN", yy->__buf+yy->__pos));
  return 1;
  l254:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RETURN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ELSE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ELSE"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l256;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "else")) goto l256;
  {  int yypos257= yy->__pos, yythunkpos257= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l257;  goto l256;
  l257:;	  yy->__pos= yypos257; yy->__thunkpos= yythunkpos257;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l256;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_ELSE, yy->__begin, yy->__end);  if (!yy__(yy)) goto l256;
  yyprintf((stderr, "  ok   %s @ %s\n", "ELSE", yy->__buf+yy->__pos));
  return 1;
  l256:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ELSE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_IF(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "IF"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l258;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "if")) goto l258;
  {  int yypos259= yy->__pos, yythunkpos259= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l259;  goto l258;
  l259:;	  yy->__pos= yypos259; yy->__thunkpos= yythunkpos259;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l258;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_IF, yy->__begin, yy->__end);  if (!yy__(yy)) goto l258;
  yyprintf((stderr, "  ok   %s @ %s\n", "IF", yy->__buf+yy->__pos));
  return 1;
  l258:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "IF", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_FOR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "FOR"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l260;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "for")) goto l260;
  {  int yypos261= yy->__pos, yythunkpos261= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l261;  goto l260;
  l261:;	  yy->__pos= yypos261; yy->__thunkpos= yythunkpos261;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l260;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_FOR, yy->__begin, yy->__end);  if (!yy__(yy)) goto l260;
  yyprintf((stderr, "  ok   %s @ %s\n", "FOR", yy->__buf+yy->__pos));
  return 1;
  l260:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "FOR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_cond(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "cond"));  if (!yy_LPAREN(yy)) goto l262;  if (!yy_expr(yy)) goto l262;  yyDo(yy, yySet, -1, 0);  if (!yy_RPAREN(yy)) goto l262;  yyDo(yy, yy_1_cond, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "cond", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l262:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "cond", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_WHILE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "WHILE"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l263;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "while")) goto l263;
  {  int yypos264= yy->__pos, yythunkpos264= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l264;  goto l263;
  l264:;	  yy->__pos= yypos264; yy->__thunkpos= yythunkpos264;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l263;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_WHILE, yy->__begin, yy->__end);  if (!yy__(yy)) goto l263;
  yyprintf((stderr, "  ok   %s @ %s\n", "WHILE", yy->__buf+yy->__pos));
  return 1;
  l263:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "WHILE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_stmt(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 7, 0);
  yyprintf((stderr, "%s\n", "stmt"));
  {  int yypos266= yy->__pos, yythunkpos266= yy->__thunkpos;  if (!yy_WHILE(yy)) goto l267;  if (!yy_cond(yy)) goto l267;  yyDo(yy, yySet, -7, 0);  if (!yy_stmt(yy)) goto l267;  yyDo(yy, yySet, -6, 0);  yyDo(yy, yy_1_stmt, yy->__begin, yy->__end);  goto l266;
  l267:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_FOR(yy)) goto l268;  if (!yy_LPAREN(yy)) goto l268;
  {  int yypos269= yy->__pos, yythunkpos269= yy->__thunkpos;  if (!yy_expropt(yy)) goto l270;  yyDo(yy, yySet, -5, 0);  if (!yy_SEMI(yy)) goto l270;  goto l269;
  l270:;	  yy->__pos= yypos269; yy->__thunkpos= yythunkpos269;  if (!yy_vardecl(yy)) goto l268;  yyDo(yy, yySet, -5, 0);
  }
  l269:;	  if (!yy_expropt(yy)) goto l268;  yyDo(yy, yySet, -7, 0);  if (!yy_SEMI(yy)) goto l268;  if (!yy_expropt(yy)) goto l268;  yyDo(yy, yySet, -4, 0);  if (!yy_RPAREN(yy)) goto l268;  if (!yy_stmt(yy)) goto l268;  yyDo(yy, yySet, -3, 0);  yyDo(yy, yy_2_stmt, yy->__begin, yy->__end);  goto l266;
  l268:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_IF(yy)) goto l271;  if (!yy_cond(yy)) goto l271;  yyDo(yy, yySet, -7, 0);  if (!yy_stmt(yy)) goto l271;  yyDo(yy, yySet, -6, 0);
  {  int yypos272= yy->__pos, yythunkpos272= yy->__thunkpos;  if (!yy_ELSE(yy)) goto l273;  if (!yy_stmt(yy)) goto l273;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_3_stmt, yy->__begin, yy->__end);  goto l272;
  l273:;	  yy->__pos= yypos272; yy->__thunkpos= yythunkpos272;  yyDo(yy, yy_4_stmt, yy->__begin, yy->__end);
  }
  l272:;	  goto l266;
  l271:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_RETURN(yy)) goto l274;  if (!yy_expropt(yy)) goto l274;  yyDo(yy, yySet, -1, 0);  if (!yy_SEMI(yy)) goto l274;  yyDo(yy, yy_5_stmt, yy->__begin, yy->__end);  goto l266;
  l274:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_CONTINU(yy)) goto l275;  if (!yy_SEMI(yy)) goto l275;  yyDo(yy, yy_6_stmt, yy->__begin, yy->__end);  goto l266;
  l275:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_BREAK(yy)) goto l276;  if (!yy_SEMI(yy)) goto l276;  yyDo(yy, yy_7_stmt, yy->__begin, yy->__end);  goto l266;
  l276:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_block(yy)) goto l277;  goto l266;
  l277:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_expr(yy)) goto l278;  yyDo(yy, yySet, -1, 0);  if (!yy_SEMI(yy)) goto l278;  yyDo(yy, yy_8_stmt, yy->__begin, yy->__end);  goto l266;
  l278:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_typedec(yy)) goto l279;  goto l266;
  l279:;	  yy->__pos= yypos266; yy->__thunkpos= yythunkpos266;  if (!yy_vardecl(yy)) goto l265;
  }
  l266:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "stmt", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 7, 0);
  return 1;
  l265:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "stmt", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_EXTERN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "EXTERN"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l280;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "extern")) goto l280;
  {  int yypos281= yy->__pos, yythunkpos281= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l281;  goto l280;
  l281:;	  yy->__pos= yypos281; yy->__thunkpos= yythunkpos281;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l280;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_EXTERN, yy->__begin, yy->__end);  if (!yy__(yy)) goto l280;
  yyprintf((stderr, "  ok   %s @ %s\n", "EXTERN", yy->__buf+yy->__pos));
  return 1;
  l280:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "EXTERN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_block(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "block"));  if (!yy_LBRACE(yy)) goto l282;  if (!yy_mkList(yy)) goto l282;  yyDo(yy, yySet, -3, 0);
  l283:;	
  {  int yypos284= yy->__pos, yythunkpos284= yy->__thunkpos;  if (!yy_stmt(yy)) goto l284;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_block, yy->__begin, yy->__end);  goto l283;
  l284:;	  yy->__pos= yypos284; yy->__thunkpos= yythunkpos284;
  }
  {  int yypos285= yy->__pos, yythunkpos285= yy->__thunkpos;  if (!yy_RBRACE(yy)) goto l286;  yyDo(yy, yy_2_block, yy->__begin, yy->__end);  goto l285;
  l286:;	  yy->__pos= yypos285; yy->__thunkpos= yythunkpos285;  if (!yy_error(yy)) goto l282;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_3_block, yy->__begin, yy->__end);
  }
  l285:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "block", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l282:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "block", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_funid(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "funid"));
  {  int yypos288= yy->__pos, yythunkpos288= yy->__thunkpos;  if (!yy_STAR(yy)) goto l289;  if (!yy_funid(yy)) goto l289;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_funid, yy->__begin, yy->__end);  goto l288;
  l289:;	  yy->__pos= yypos288; yy->__thunkpos= yythunkpos288;  if (!yy_LPAREN(yy)) goto l290;  if (!yy_funid(yy)) goto l290;  yyDo(yy, yySet, -1, 0);  if (!yy_RPAREN(yy)) goto l290;  yyDo(yy, yy_2_funid, yy->__begin, yy->__end);  goto l288;
  l290:;	  yy->__pos= yypos288; yy->__thunkpos= yythunkpos288;  if (!yy_id(yy)) goto l287;
  }
  l288:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "funid", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l287:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "funid", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_DOT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "DOT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l291;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '.')) goto l291;
  {  int yypos292= yy->__pos, yythunkpos292= yy->__thunkpos;  if (!yymatchChar(yy, '.')) goto l292;  goto l291;
  l292:;	  yy->__pos= yypos292; yy->__thunkpos= yythunkpos292;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l291;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_DOT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l291;
  yyprintf((stderr, "  ok   %s @ %s\n", "DOT", yy->__buf+yy->__pos));
  return 1;
  l291:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "DOT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_initelt(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 4, 0);
  yyprintf((stderr, "%s\n", "initelt"));
  {  int yypos294= yy->__pos, yythunkpos294= yy->__thunkpos;  if (!yy_DOT(yy)) goto l295;  yyDo(yy, yySet, -4, 0);  if (!yy_id(yy)) goto l295;  yyDo(yy, yySet, -3, 0);  if (!yy_ASSIGN(yy)) goto l295;  yyDo(yy, yySet, -2, 0);  if (!yy_expr(yy)) goto l295;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_initelt, yy->__begin, yy->__end);  goto l294;
  l295:;	  yy->__pos= yypos294; yy->__thunkpos= yythunkpos294;  if (!yy_LBRAK(yy)) goto l296;  yyDo(yy, yySet, -4, 0);  if (!yy_expr(yy)) goto l296;  yyDo(yy, yySet, -3, 0);  if (!yy_RBRAK(yy)) goto l296;  if (!yy_ASSIGN(yy)) goto l296;  yyDo(yy, yySet, -2, 0);  if (!yy_expr(yy)) goto l296;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_initelt, yy->__begin, yy->__end);  goto l294;
  l296:;	  yy->__pos= yypos294; yy->__thunkpos= yythunkpos294;  if (!yy_initor(yy)) goto l293;
  }
  l294:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "initelt", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 4, 0);
  return 1;
  l293:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "initelt", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_expr(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "expr"));  if (!yy_assign(yy)) goto l297;
  yyprintf((stderr, "  ok   %s @ %s\n", "expr", yy->__buf+yy->__pos));
  return 1;
  l297:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "expr", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_agrinit(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "agrinit"));  if (!yy_LBRACE(yy)) goto l298;  if (!yy_mkList(yy)) goto l298;  yyDo(yy, yySet, -2, 0);
  {  int yypos299= yy->__pos, yythunkpos299= yy->__thunkpos;  if (!yy_initelt(yy)) goto l299;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_agrinit, yy->__begin, yy->__end);
  l301:;	
  {  int yypos302= yy->__pos, yythunkpos302= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l302;  if (!yy_initelt(yy)) goto l302;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_agrinit, yy->__begin, yy->__end);  goto l301;
  l302:;	  yy->__pos= yypos302; yy->__thunkpos= yythunkpos302;
  }
  {  int yypos303= yy->__pos, yythunkpos303= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l303;  goto l304;
  l303:;	  yy->__pos= yypos303; yy->__thunkpos= yythunkpos303;
  }
  l304:;	  goto l300;
  l299:;	  yy->__pos= yypos299; yy->__thunkpos= yythunkpos299;
  }
  l300:;	  if (!yy_RBRACE(yy)) goto l298;  yyDo(yy, yy_3_agrinit, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "agrinit", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l298:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "agrinit", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ETC(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ETC"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l305;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "...")) goto l305;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l305;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_ETC, yy->__begin, yy->__end);  if (!yy__(yy)) goto l305;
  yyprintf((stderr, "  ok   %s @ %s\n", "ETC", yy->__buf+yy->__pos));
  return 1;
  l305:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ETC", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_pdecl(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "pdecl"));  if (!yy_tname(yy)) goto l306;  yyDo(yy, yySet, -2, 0);  if (!yy_decltor(yy)) goto l306;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_pdecl, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "pdecl", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l306:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "pdecl", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_params(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "params"));  if (!yy_LPAREN(yy)) goto l307;  if (!yy_mkList(yy)) goto l307;  yyDo(yy, yySet, -3, 0);
  {  int yypos308= yy->__pos, yythunkpos308= yy->__thunkpos;  if (!yy_pdecl(yy)) goto l308;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_params, yy->__begin, yy->__end);
  l310:;	
  {  int yypos311= yy->__pos, yythunkpos311= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l311;  if (!yy_pdecl(yy)) goto l311;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_2_params, yy->__begin, yy->__end);  goto l310;
  l311:;	  yy->__pos= yypos311; yy->__thunkpos= yythunkpos311;
  }  goto l309;
  l308:;	  yy->__pos= yypos308; yy->__thunkpos= yythunkpos308;
  }
  l309:;	
  {  int yypos312= yy->__pos, yythunkpos312= yy->__thunkpos;
  {  int yypos314= yy->__pos, yythunkpos314= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l314;  if (!yy_ETC(yy)) goto l314;  yyDo(yy, yy_3_params, yy->__begin, yy->__end);  goto l315;
  l314:;	  yy->__pos= yypos314; yy->__thunkpos= yythunkpos314;
  }
  l315:;	  if (!yy_RPAREN(yy)) goto l313;  yyDo(yy, yy_4_params, yy->__begin, yy->__end);  goto l312;
  l313:;	  yy->__pos= yypos312; yy->__thunkpos= yythunkpos312;  if (!yy_error(yy)) goto l307;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_5_params, yy->__begin, yy->__end);
  }
  l312:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "params", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l307:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "params", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RBRAK(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RBRAK"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l316;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, ']')) goto l316;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l316;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_RBRAK, yy->__begin, yy->__end);  if (!yy__(yy)) goto l316;
  yyprintf((stderr, "  ok   %s @ %s\n", "RBRAK", yy->__buf+yy->__pos));
  return 1;
  l316:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RBRAK", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_expropt(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "expropt"));
  {  int yypos318= yy->__pos, yythunkpos318= yy->__thunkpos;  if (!yy_expr(yy)) goto l319;  goto l318;
  l319:;	  yy->__pos= yypos318; yy->__thunkpos= yythunkpos318;  yyDo(yy, yy_1_expropt, yy->__begin, yy->__end);
  }
  l318:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "expropt", yy->__buf+yy->__pos));
  return 1;
  l317:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "expropt", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LBRAK(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LBRAK"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l320;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '[')) goto l320;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l320;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_LBRAK, yy->__begin, yy->__end);  if (!yy__(yy)) goto l320;
  yyprintf((stderr, "  ok   %s @ %s\n", "LBRAK", yy->__buf+yy->__pos));
  return 1;
  l320:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LBRAK", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_idopt(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "idopt"));
  {  int yypos322= yy->__pos, yythunkpos322= yy->__thunkpos;  if (!yy_id(yy)) goto l323;  goto l322;
  l323:;	  yy->__pos= yypos322; yy->__thunkpos= yythunkpos322;  yyDo(yy, yy_1_idopt, yy->__begin, yy->__end);
  }
  l322:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "idopt", yy->__buf+yy->__pos));
  return 1;
  l321:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "idopt", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RPAREN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RPAREN"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l324;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, ')')) goto l324;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l324;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_RPAREN, yy->__begin, yy->__end);  if (!yy__(yy)) goto l324;
  yyprintf((stderr, "  ok   %s @ %s\n", "RPAREN", yy->__buf+yy->__pos));
  return 1;
  l324:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RPAREN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LPAREN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LPAREN"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l325;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '(')) goto l325;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l325;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_LPAREN, yy->__begin, yy->__end);  if (!yy__(yy)) goto l325;
  yyprintf((stderr, "  ok   %s @ %s\n", "LPAREN", yy->__buf+yy->__pos));
  return 1;
  l325:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LPAREN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ddector(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "ddector"));
  {  int yypos327= yy->__pos, yythunkpos327= yy->__thunkpos;  if (!yy_LPAREN(yy)) goto l328;  if (!yy_decltor(yy)) goto l328;  yyDo(yy, yySet, -3, 0);  if (!yy_RPAREN(yy)) goto l328;  goto l327;
  l328:;	  yy->__pos= yypos327; yy->__thunkpos= yythunkpos327;  if (!yy_idopt(yy)) goto l326;  yyDo(yy, yySet, -3, 0);
  }
  l327:;	
  l329:;	
  {  int yypos330= yy->__pos, yythunkpos330= yy->__thunkpos;
  {  int yypos331= yy->__pos, yythunkpos331= yy->__thunkpos;  if (!yy_LBRAK(yy)) goto l332;  if (!yy_expropt(yy)) goto l332;  yyDo(yy, yySet, -2, 0);  if (!yy_RBRAK(yy)) goto l332;  yyDo(yy, yy_1_ddector, yy->__begin, yy->__end);  goto l331;
  l332:;	  yy->__pos= yypos331; yy->__thunkpos= yythunkpos331;  if (!yy_params(yy)) goto l330;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_ddector, yy->__begin, yy->__end);
  }
  l331:;	  goto l329;
  l330:;	  yy->__pos= yypos330; yy->__thunkpos= yythunkpos330;
  }  yyDo(yy, yy_3_ddector, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "ddector", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l326:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ddector", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_STAR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "STAR"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l333;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '*')) goto l333;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l333;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_STAR, yy->__begin, yy->__end);  if (!yy__(yy)) goto l333;
  yyprintf((stderr, "  ok   %s @ %s\n", "STAR", yy->__buf+yy->__pos));
  return 1;
  l333:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "STAR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_initor(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "initor"));
  {  int yypos335= yy->__pos, yythunkpos335= yy->__thunkpos;  if (!yy_agrinit(yy)) goto l336;  goto l335;
  l336:;	  yy->__pos= yypos335; yy->__thunkpos= yythunkpos335;  if (!yy_expr(yy)) goto l334;
  }
  l335:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "initor", yy->__buf+yy->__pos));
  return 1;
  l334:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "initor", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_ASSIGN(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "ASSIGN"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l337;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '=')) goto l337;
  {  int yypos338= yy->__pos, yythunkpos338= yy->__thunkpos;  if (!yymatchChar(yy, '=')) goto l338;  goto l337;
  l338:;	  yy->__pos= yypos338; yy->__thunkpos= yythunkpos338;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l337;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_ASSIGN, yy->__begin, yy->__end);  if (!yy__(yy)) goto l337;
  yyprintf((stderr, "  ok   %s @ %s\n", "ASSIGN", yy->__buf+yy->__pos));
  return 1;
  l337:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "ASSIGN", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_RBRACE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "RBRACE"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l339;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '}')) goto l339;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l339;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_RBRACE, yy->__begin, yy->__end);  if (!yy__(yy)) goto l339;
  yyprintf((stderr, "  ok   %s @ %s\n", "RBRACE", yy->__buf+yy->__pos));
  return 1;
  l339:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "RBRACE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_mkList(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "mkList"));  yyDo(yy, yy_1_mkList, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "mkList", yy->__buf+yy->__pos));
  return 1;
  l340:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "mkList", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LBRACE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LBRACE"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l341;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '{')) goto l341;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l341;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_LBRACE, yy->__begin, yy->__end);  if (!yy__(yy)) goto l341;
  yyprintf((stderr, "  ok   %s @ %s\n", "LBRACE", yy->__buf+yy->__pos));
  return 1;
  l341:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LBRACE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_members(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "members"));  if (!yy_LBRACE(yy)) goto l342;  if (!yy_mkList(yy)) goto l342;  yyDo(yy, yySet, -3, 0);
  l343:;	
  {  int yypos344= yy->__pos, yythunkpos344= yy->__thunkpos;  if (!yy_vardecl(yy)) goto l344;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_members, yy->__begin, yy->__end);  goto l343;
  l344:;	  yy->__pos= yypos344; yy->__thunkpos= yythunkpos344;
  }
  {  int yypos345= yy->__pos, yythunkpos345= yy->__thunkpos;  if (!yy_RBRACE(yy)) goto l346;  goto l345;
  l346:;	  yy->__pos= yypos345; yy->__thunkpos= yythunkpos345;  if (!yy_error(yy)) goto l342;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_members, yy->__begin, yy->__end);
  }
  l345:;	  yyDo(yy, yy_3_members, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "members", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l342:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "members", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_STRUCT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "STRUCT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l347;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "struct")) goto l347;
  {  int yypos348= yy->__pos, yythunkpos348= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l348;  goto l347;
  l348:;	  yy->__pos= yypos348; yy->__thunkpos= yythunkpos348;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l347;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_STRUCT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l347;
  yyprintf((stderr, "  ok   %s @ %s\n", "STRUCT", yy->__buf+yy->__pos));
  return 1;
  l347:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "STRUCT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_id(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "id"));
  {  int yypos350= yy->__pos, yythunkpos350= yy->__thunkpos;  if (!yy_keyword(yy)) goto l350;  goto l349;
  l350:;	  yy->__pos= yypos350; yy->__thunkpos= yythunkpos350;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l349;
#undef yytext
#undef yyleng
  }  if (!yy_alpha(yy)) goto l349;
  l351:;	
  {  int yypos352= yy->__pos, yythunkpos352= yy->__thunkpos;  if (!yy_alnum(yy)) goto l352;  goto l351;
  l352:;	  yy->__pos= yypos352; yy->__thunkpos= yythunkpos352;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l349;
#undef yytext
#undef yyleng
  }  if (!yy__(yy)) goto l349;  yyDo(yy, yy_1_id, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "id", yy->__buf+yy->__pos));
  return 1;
  l349:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "id", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_struct(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "struct"));  if (!yy_STRUCT(yy)) goto l353;
  {  int yypos354= yy->__pos, yythunkpos354= yy->__thunkpos;  if (!yy_id(yy)) goto l355;  yyDo(yy, yySet, -3, 0);  if (!yy_members(yy)) goto l355;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_struct, yy->__begin, yy->__end);  goto l354;
  l355:;	  yy->__pos= yypos354; yy->__thunkpos= yythunkpos354;  if (!yy_id(yy)) goto l356;  yyDo(yy, yySet, -3, 0);  yyDo(yy, yy_2_struct, yy->__begin, yy->__end);  goto l354;
  l356:;	  yy->__pos= yypos354; yy->__thunkpos= yythunkpos354;  if (!yy_members(yy)) goto l357;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_3_struct, yy->__begin, yy->__end);  goto l354;
  l357:;	  yy->__pos= yypos354; yy->__thunkpos= yythunkpos354;  if (!yy_error(yy)) goto l353;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_4_struct, yy->__begin, yy->__end);
  }
  l354:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "struct", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l353:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "struct", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_DOUBLE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "DOUBLE"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l358;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "double")) goto l358;
  {  int yypos359= yy->__pos, yythunkpos359= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l359;  goto l358;
  l359:;	  yy->__pos= yypos359; yy->__thunkpos= yythunkpos359;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l358;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_DOUBLE, yy->__begin, yy->__end);  if (!yy__(yy)) goto l358;
  yyprintf((stderr, "  ok   %s @ %s\n", "DOUBLE", yy->__buf+yy->__pos));
  return 1;
  l358:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "DOUBLE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_FLOAT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "FLOAT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l360;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "float")) goto l360;
  {  int yypos361= yy->__pos, yythunkpos361= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l361;  goto l360;
  l361:;	  yy->__pos= yypos361; yy->__thunkpos= yythunkpos361;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l360;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_FLOAT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l360;
  yyprintf((stderr, "  ok   %s @ %s\n", "FLOAT", yy->__buf+yy->__pos));
  return 1;
  l360:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "FLOAT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_LONG(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "LONG"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l362;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "long")) goto l362;
  {  int yypos363= yy->__pos, yythunkpos363= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l363;  goto l362;
  l363:;	  yy->__pos= yypos363; yy->__thunkpos= yythunkpos363;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l362;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_LONG, yy->__begin, yy->__end);  if (!yy__(yy)) goto l362;
  yyprintf((stderr, "  ok   %s @ %s\n", "LONG", yy->__buf+yy->__pos));
  return 1;
  l362:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "LONG", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_INT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "INT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l364;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "int")) goto l364;
  {  int yypos365= yy->__pos, yythunkpos365= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l365;  goto l364;
  l365:;	  yy->__pos= yypos365; yy->__thunkpos= yythunkpos365;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l364;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_INT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l364;
  yyprintf((stderr, "  ok   %s @ %s\n", "INT", yy->__buf+yy->__pos));
  return 1;
  l364:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "INT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_SHORT(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "SHORT"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l366;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "short")) goto l366;
  {  int yypos367= yy->__pos, yythunkpos367= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l367;  goto l366;
  l367:;	  yy->__pos= yypos367; yy->__thunkpos= yythunkpos367;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l366;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_SHORT, yy->__begin, yy->__end);  if (!yy__(yy)) goto l366;
  yyprintf((stderr, "  ok   %s @ %s\n", "SHORT", yy->__buf+yy->__pos));
  return 1;
  l366:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "SHORT", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_CHAR(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "CHAR"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l368;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "char")) goto l368;
  {  int yypos369= yy->__pos, yythunkpos369= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l369;  goto l368;
  l369:;	  yy->__pos= yypos369; yy->__thunkpos= yythunkpos369;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l368;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_CHAR, yy->__begin, yy->__end);  if (!yy__(yy)) goto l368;
  yyprintf((stderr, "  ok   %s @ %s\n", "CHAR", yy->__buf+yy->__pos));
  return 1;
  l368:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "CHAR", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_VOID(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "VOID"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l370;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "void")) goto l370;
  {  int yypos371= yy->__pos, yythunkpos371= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l371;  goto l370;
  l371:;	  yy->__pos= yypos371; yy->__thunkpos= yythunkpos371;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l370;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_VOID, yy->__begin, yy->__end);  if (!yy__(yy)) goto l370;
  yyprintf((stderr, "  ok   %s @ %s\n", "VOID", yy->__buf+yy->__pos));
  return 1;
  l370:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "VOID", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_inidecl(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "inidecl"));  if (!yy_decltor(yy)) goto l372;  yyDo(yy, yySet, -3, 0);
  {  int yypos373= yy->__pos, yythunkpos373= yy->__thunkpos;  if (!yy_ASSIGN(yy)) goto l374;  yyDo(yy, yySet, -2, 0);
  {  int yypos375= yy->__pos, yythunkpos375= yy->__thunkpos;  if (!yy_initor(yy)) goto l376;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_inidecl, yy->__begin, yy->__end);  goto l375;
  l376:;	  yy->__pos= yypos375; yy->__thunkpos= yythunkpos375;  if (!yy_error(yy)) goto l374;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_inidecl, yy->__begin, yy->__end);
  }
  l375:;	  goto l373;
  l374:;	  yy->__pos= yypos373; yy->__thunkpos= yythunkpos373;  yyDo(yy, yy_3_inidecl, yy->__begin, yy->__end);
  }
  l373:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "inidecl", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l372:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "inidecl", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_SEMI(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "SEMI"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l377;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, ';')) goto l377;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l377;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_SEMI, yy->__begin, yy->__end);  if (!yy__(yy)) goto l377;
  yyprintf((stderr, "  ok   %s @ %s\n", "SEMI", yy->__buf+yy->__pos));
  return 1;
  l377:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "SEMI", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_COMMA(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "COMMA"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l378;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, ',')) goto l378;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l378;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_COMMA, yy->__begin, yy->__end);  if (!yy__(yy)) goto l378;
  yyprintf((stderr, "  ok   %s @ %s\n", "COMMA", yy->__buf+yy->__pos));
  return 1;
  l378:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "COMMA", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_decltor(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "decltor"));
  {  int yypos380= yy->__pos, yythunkpos380= yy->__thunkpos;  if (!yy_STAR(yy)) goto l381;  if (!yy_decltor(yy)) goto l381;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_decltor, yy->__begin, yy->__end);  goto l380;
  l381:;	  yy->__pos= yypos380; yy->__thunkpos= yythunkpos380;  if (!yy_ddector(yy)) goto l379;
  }
  l380:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "decltor", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 1, 0);
  return 1;
  l379:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "decltor", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_tname(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "tname"));
  {  int yypos383= yy->__pos, yythunkpos383= yy->__thunkpos;  if (!yy_VOID(yy)) goto l384;  yyDo(yy, yy_1_tname, yy->__begin, yy->__end);  goto l383;
  l384:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_CHAR(yy)) goto l385;  yyDo(yy, yy_2_tname, yy->__begin, yy->__end);  goto l383;
  l385:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_SHORT(yy)) goto l386;  yyDo(yy, yy_3_tname, yy->__begin, yy->__end);  goto l383;
  l386:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_INT(yy)) goto l387;  yyDo(yy, yy_4_tname, yy->__begin, yy->__end);  goto l383;
  l387:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_LONG(yy)) goto l388;  yyDo(yy, yy_5_tname, yy->__begin, yy->__end);  goto l383;
  l388:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_FLOAT(yy)) goto l389;  yyDo(yy, yy_6_tname, yy->__begin, yy->__end);  goto l383;
  l389:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_DOUBLE(yy)) goto l390;  yyDo(yy, yy_7_tname, yy->__begin, yy->__end);  goto l383;
  l390:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_struct(yy)) goto l391;  goto l383;
  l391:;	  yy->__pos= yypos383; yy->__thunkpos= yythunkpos383;  if (!yy_id(yy)) goto l382;
  }
  l383:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "tname", yy->__buf+yy->__pos));
  return 1;
  l382:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "tname", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_TYPEDEF(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "TYPEDEF"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l392;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "typedef")) goto l392;
  {  int yypos393= yy->__pos, yythunkpos393= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l393;  goto l392;
  l393:;	  yy->__pos= yypos393; yy->__thunkpos= yythunkpos393;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l392;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_TYPEDEF, yy->__begin, yy->__end);  if (!yy__(yy)) goto l392;
  yyprintf((stderr, "  ok   %s @ %s\n", "TYPEDEF", yy->__buf+yy->__pos));
  return 1;
  l392:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "TYPEDEF", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_vardecl(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "vardecl"));  if (!yy_tname(yy)) goto l394;  yyDo(yy, yySet, -3, 0);  if (!yy_inidecl(yy)) goto l394;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_vardecl, yy->__begin, yy->__end);
  l395:;	
  {  int yypos396= yy->__pos, yythunkpos396= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l396;  if (!yy_inidecl(yy)) goto l396;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_vardecl, yy->__begin, yy->__end);  goto l395;
  l396:;	  yy->__pos= yypos396; yy->__thunkpos= yythunkpos396;
  }  if (!yy_SEMI(yy)) goto l394;  yyDo(yy, yy_3_vardecl, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "vardecl", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l394:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "vardecl", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_primdef(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 3, 0);
  yyprintf((stderr, "%s\n", "primdef"));  if (!yy_EXTERN(yy)) goto l397;  if (!yy_tname(yy)) goto l397;  yyDo(yy, yySet, -3, 0);  if (!yy_funid(yy)) goto l397;  yyDo(yy, yySet, -2, 0);  if (!yy_params(yy)) goto l397;  yyDo(yy, yySet, -1, 0);  if (!yy_SEMI(yy)) goto l397;  yyDo(yy, yy_1_primdef, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "primdef", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 3, 0);
  return 1;
  l397:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "primdef", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_fundefn(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 4, 0);
  yyprintf((stderr, "%s\n", "fundefn"));  if (!yy_tname(yy)) goto l398;  yyDo(yy, yySet, -4, 0);  if (!yy_funid(yy)) goto l398;  yyDo(yy, yySet, -3, 0);  if (!yy_params(yy)) goto l398;  yyDo(yy, yySet, -2, 0);  if (!yy_block(yy)) goto l398;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_1_fundefn, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "fundefn", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 4, 0);
  return 1;
  l398:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "fundefn", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_typedec(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 4, 0);
  yyprintf((stderr, "%s\n", "typedec"));  if (!yy_TYPEDEF(yy)) goto l399;  yyDo(yy, yySet, -4, 0);  if (!yy_tname(yy)) goto l399;  yyDo(yy, yySet, -3, 0);  if (!yy_decltor(yy)) goto l399;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_1_typedec, yy->__begin, yy->__end);
  l400:;	
  {  int yypos401= yy->__pos, yythunkpos401= yy->__thunkpos;  if (!yy_COMMA(yy)) goto l401;  if (!yy_decltor(yy)) goto l401;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_2_typedec, yy->__begin, yy->__end);  goto l400;
  l401:;	  yy->__pos= yypos401; yy->__thunkpos= yythunkpos401;
  }  if (!yy_SEMI(yy)) goto l399;  yyDo(yy, yy_3_typedec, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "typedec", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 4, 0);
  return 1;
  l399:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "typedec", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_INCLUDE(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "INCLUDE"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l402;
#undef yytext
#undef yyleng
  }  if (!yymatchString(yy, "include")) goto l402;
  {  int yypos403= yy->__pos, yythunkpos403= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l403;  goto l402;
  l403:;	  yy->__pos= yypos403; yy->__thunkpos= yythunkpos403;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l402;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_INCLUDE, yy->__begin, yy->__end);  if (!yy__(yy)) goto l402;
  yyprintf((stderr, "  ok   %s @ %s\n", "INCLUDE", yy->__buf+yy->__pos));
  return 1;
  l402:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "INCLUDE", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_HASH(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "HASH"));  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l404;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '#')) goto l404;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l404;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_HASH, yy->__begin, yy->__end);  if (!yy__(yy)) goto l404;
  yyprintf((stderr, "  ok   %s @ %s\n", "HASH", yy->__buf+yy->__pos));
  return 1;
  l404:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "HASH", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_eol(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "eol"));
  {  int yypos406= yy->__pos, yythunkpos406= yy->__thunkpos;  if (!yymatchChar(yy, '\n')) goto l407;
  {  int yypos408= yy->__pos, yythunkpos408= yy->__thunkpos;  if (!yymatchChar(yy, '\r')) goto l408;  goto l409;
  l408:;	  yy->__pos= yypos408; yy->__thunkpos= yythunkpos408;
  }
  l409:;	  goto l406;
  l407:;	  yy->__pos= yypos406; yy->__thunkpos= yythunkpos406;  if (!yymatchChar(yy, '\r')) goto l405;
  {  int yypos410= yy->__pos, yythunkpos410= yy->__thunkpos;  if (!yymatchChar(yy, '\n')) goto l410;  goto l411;
  l410:;	  yy->__pos= yypos410; yy->__thunkpos= yythunkpos410;
  }
  l411:;	
  }
  l406:;	  yyDo(yy, yy_1_eol, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "eol", yy->__buf+yy->__pos));
  return 1;
  l405:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "eol", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_error(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "error"));  yyText(yy, yy->__begin, yy->__end);
#define yytext yy->__text
#define yyleng yy->__textlen
 errorLine = get(input, Input,line) ;
#undef yytext
#undef yyleng
  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l412;
#undef yytext
#undef yyleng
  }
  l413:;	
  {  int yypos414= yy->__pos, yythunkpos414= yy->__thunkpos;
  {  int yypos415= yy->__pos, yythunkpos415= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l415;  goto l414;
  l415:;	  yy->__pos= yypos415; yy->__thunkpos= yythunkpos415;
  }  if (!yymatchDot(yy)) goto l414;  goto l413;
  l414:;	  yy->__pos= yypos414; yy->__thunkpos= yythunkpos414;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l412;
#undef yytext
#undef yyleng
  }  yyDo(yy, yy_1_error, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "error", yy->__buf+yy->__pos));
  return 1;
  l412:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "error", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_tldecl(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "tldecl"));
  {  int yypos417= yy->__pos, yythunkpos417= yy->__thunkpos;  if (!yy_typedec(yy)) goto l418;  goto l417;
  l418:;	  yy->__pos= yypos417; yy->__thunkpos= yythunkpos417;  if (!yy_fundefn(yy)) goto l419;  goto l417;
  l419:;	  yy->__pos= yypos417; yy->__thunkpos= yythunkpos417;  if (!yy_primdef(yy)) goto l420;  goto l417;
  l420:;	  yy->__pos= yypos417; yy->__thunkpos= yythunkpos417;  if (!yy_vardecl(yy)) goto l416;
  }
  l417:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "tldecl", yy->__buf+yy->__pos));
  return 1;
  l416:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "tldecl", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_include(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "include"));  if (!yy_HASH(yy)) goto l421;  if (!yy_INCLUDE(yy)) goto l421;
  {  int yypos422= yy->__pos, yythunkpos422= yy->__thunkpos;  if (!yymatchChar(yy, '<')) goto l423;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l423;
#undef yytext
#undef yyleng
  }
  l424:;	
  {  int yypos425= yy->__pos, yythunkpos425= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\100\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l425;  goto l424;
  l425:;	  yy->__pos= yypos425; yy->__thunkpos= yythunkpos425;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l423;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '>')) goto l423;  yyText(yy, yy->__begin, yy->__end);
#define yytext yy->__text
#define yyleng yy->__textlen
 pushInput(yytext, sysOpen(yytext)) ;
#undef yytext
#undef yyleng
  goto l422;
  l423:;	  yy->__pos= yypos422; yy->__thunkpos= yythunkpos422;  if (!yymatchChar(yy, '"')) goto l421;  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_BEGIN)) goto l421;
#undef yytext
#undef yyleng
  }
  l426:;	
  {  int yypos427= yy->__pos, yythunkpos427= yy->__thunkpos;  if (!yymatchClass(yy, (unsigned char *)"\000\000\000\000\000\100\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l427;  goto l426;
  l427:;	  yy->__pos= yypos427; yy->__thunkpos= yythunkpos427;
  }  yyText(yy, yy->__begin, yy->__end);  {
#define yytext yy->__text
#define yyleng yy->__textlen
if (!(YY_END)) goto l421;
#undef yytext
#undef yyleng
  }  if (!yymatchChar(yy, '"')) goto l421;  yyText(yy, yy->__begin, yy->__end);
#define yytext yy->__text
#define yyleng yy->__textlen
 pushInput(yytext, usrOpen(yytext)) ;
#undef yytext
#undef yyleng

  }
  l422:;	  yyDo(yy, yy_1_include, yy->__begin, yy->__end);
  yyprintf((stderr, "  ok   %s @ %s\n", "include", yy->__buf+yy->__pos));
  return 1;
  l421:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "include", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy_interp(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;
  yyprintf((stderr, "%s\n", "interp"));  if (!yymatchString(yy, "#!")) goto l428;
  l429:;	
  {  int yypos430= yy->__pos, yythunkpos430= yy->__thunkpos;
  {  int yypos431= yy->__pos, yythunkpos431= yy->__thunkpos;  if (!yy_eol(yy)) goto l431;  goto l430;
  l431:;	  yy->__pos= yypos431; yy->__thunkpos= yythunkpos431;
  }  if (!yymatchDot(yy)) goto l430;  goto l429;
  l430:;	  yy->__pos= yypos430; yy->__thunkpos= yythunkpos430;
  }  if (!yy_eol(yy)) goto l428;
  yyprintf((stderr, "  ok   %s @ %s\n", "interp", yy->__buf+yy->__pos));
  return 1;
  l428:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "interp", yy->__buf+yy->__pos));
  return 0;
}
YY_RULE(int) yy__(yycontext *yy)
{
  yyprintf((stderr, "%s\n", "_"));
  l433:;	
  {  int yypos434= yy->__pos, yythunkpos434= yy->__thunkpos;  if (!yy_blank(yy)) goto l434;  goto l433;
  l434:;	  yy->__pos= yypos434; yy->__thunkpos= yythunkpos434;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "_", yy->__buf+yy->__pos));
  return 1;
}
YY_RULE(int) yy_start(yycontext *yy)
{  int yypos0= yy->__pos, yythunkpos0= yy->__thunkpos;  yyDo(yy, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "start"));  if (!yy__(yy)) goto l435;
  {  int yypos436= yy->__pos, yythunkpos436= yy->__thunkpos;  if (!yy_interp(yy)) goto l437;  yyDo(yy, yy_1_start, yy->__begin, yy->__end);  goto l436;
  l437:;	  yy->__pos= yypos436; yy->__thunkpos= yythunkpos436;  if (!yy_include(yy)) goto l438;  yyDo(yy, yy_2_start, yy->__begin, yy->__end);  goto l436;
  l438:;	  yy->__pos= yypos436; yy->__thunkpos= yythunkpos436;  if (!yy_tldecl(yy)) goto l439;  yyDo(yy, yySet, -2, 0);  yyDo(yy, yy_3_start, yy->__begin, yy->__end);  goto l436;
  l439:;	  yy->__pos= yypos436; yy->__thunkpos= yythunkpos436;
  {  int yypos441= yy->__pos, yythunkpos441= yy->__thunkpos;  if (!yymatchDot(yy)) goto l441;  goto l440;
  l441:;	  yy->__pos= yypos441; yy->__thunkpos= yythunkpos441;
  }  yyText(yy, yy->__begin, yy->__end);
#define yytext yy->__text
#define yyleng yy->__textlen
 popInput() ;
#undef yytext
#undef yyleng
  yyDo(yy, yy_4_start, yy->__begin, yy->__end);  goto l436;
  l440:;	  yy->__pos= yypos436; yy->__thunkpos= yythunkpos436;  if (!yy_error(yy)) goto l435;  yyDo(yy, yySet, -1, 0);  yyDo(yy, yy_5_start, yy->__begin, yy->__end);
  }
  l436:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "start", yy->__buf+yy->__pos));  yyDo(yy, yyPop, 2, 0);
  return 1;
  l435:;	  yy->__pos= yypos0; yy->__thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "start", yy->__buf+yy->__pos));
  return 0;
}

#ifndef YY_PART

typedef int (*yyrule)(yycontext *yy);

YY_PARSE(int) YYPARSEFROM(YY_CTX_PARAM_ yyrule yystart)
{
  int yyok;
  if (!yyctx->__buflen)
    {
      yyctx->__buflen= YY_BUFFER_SIZE;
      yyctx->__buf= (char *)YY_MALLOC(yyctx, yyctx->__buflen);
      yyctx->__textlen= YY_BUFFER_SIZE;
      yyctx->__text= (char *)YY_MALLOC(yyctx, yyctx->__textlen);
      yyctx->__thunkslen= YY_STACK_SIZE;
      yyctx->__thunks= (yythunk *)YY_MALLOC(yyctx, sizeof(yythunk) * yyctx->__thunkslen);
      yyctx->__valslen= YY_STACK_SIZE;
      yyctx->__vals= (YYSTYPE *)YY_MALLOC(yyctx, sizeof(YYSTYPE) * yyctx->__valslen);
      yyctx->__begin= yyctx->__end= yyctx->__pos= yyctx->__limit= yyctx->__thunkpos= 0;
    }
  yyctx->__begin= yyctx->__end= yyctx->__pos;
  yyctx->__thunkpos= 0;
  yyctx->__val= yyctx->__vals;
  yyok= yystart(yyctx);
  if (yyok) yyDone(yyctx);
  yyCommit(yyctx);
  return yyok;
}

YY_PARSE(int) YYPARSE(YY_CTX_PARAM)
{
  return YYPARSEFROM(YY_CTX_ARG_ yy_start);
}

YY_PARSE(yycontext *) YYRELEASE(yycontext *yyctx)
{
  if (yyctx->__buflen)
    {
      yyctx->__buflen= 0;
      YY_FREE(yyctx, yyctx->__buf);
      YY_FREE(yyctx, yyctx->__text);
      YY_FREE(yyctx, yyctx->__thunks);
      YY_FREE(yyctx, yyctx->__vals);
    }
  return yyctx;
}

#endif
#line 2142 "main.leg"

;

#include <setjmp.h>

enum { NLR_INIT = 0, NLR_RETURN, NLR_CONTINUE, NLR_BREAK };

Object  *nlrValue = 0;

jmp_buf *nlrStack = 0;
int      nlrCount = 0;
int      nlrMax   = 0;

void _nlrPush(void)
{
    if (nlrCount >= nlrMax)
	nlrStack = realloc(nlrStack, sizeof(*nlrStack) * (nlrMax += 8));
}

#define nlrPush()	setjmp((_nlrPush(), nlrStack[nlrCount++]))

oop nlrPop(void)
{
    assert(nlrCount > 0);
    --nlrCount;
    return nlrValue;
}

#define nlrReturn(TYPE, VAL)	((nlrValue = (VAL), longjmp(nlrStack[nlrCount-1], TYPE)))

#define IBINOP(L, OP, R)	newInteger(integerValue(L) OP integerValue(R))
#define IRELOP(L, OP, R)	(integerValue(L) OP integerValue(R) ? true : false)

#define FBINOP(L, OP, R)	newFloat(floatValue(L) OP floatValue(R))
#define FRELOP(L, OP, R)	(floatValue(L) OP floatValue(R) ? true : false)

oop declareVariable(oop name, oop type, oop value, int isdead);

oop apply(oop function, oop arguments, oop env)
{
    if (opt_v > 2) { printf("APPLY ");  println(function); }
    switch (getType(function)) {
	default: {
	    fatal("type %s is not callable", getTypeName(function));
	}
	case Primitive: {
	    oop argv = newList();
	    List_do(arguments, arg) List_append(argv, eval(arg));
	    return get(function, Primitive,function)
		( get(argv, List,size),
		  get(argv, List,elements),
		  env );
	}
	case Function: {
	    oop parameters = get(function, Function,parameters);
	    oop body       = get(function, Function,body);
	    int variadic   = get(function, Function,variadic);
	    int parc       = get(parameters, List,size);
	    int argc       = get(arguments,  List,size);
	    if (argc < parc)
		fatal("too few arguments calling %s", toString(function));
	    if (argc > parc && !variadic)
		fatal("too many arguments calling %s", toString(function));
	    oop *parv = get(parameters, List,elements);
	    oop *argv = get(arguments,  List,elements);
	    Scope_begin();
	    int  argn = 0;
	    while (argn < parc) {
		oop var = parv[argn];
		oop arg = argv[argn];
		declareVariable(get(var, Variable,name), get(var, Variable,type), eval(arg), get(var, Variable,isdead));
		++argn;
	    }
	    if (argn < argc) { // put varargs array in local variable called "..."
		oop etc = newList();
		while (argn < argc) List_append(etc, eval(argv[argn++]));
		declareVariable(s_etc, t_etc, etc,0);
	    }
	    switch (nlrPush()) { // longjmp occurred
		case NLR_INIT:     break;
		case NLR_RETURN:   Scope_end();  return nlrPop();
		case NLR_CONTINUE: fatal("continue outside loop");
		case NLR_BREAK:	   fatal("break outside loop");
	    }
	    oop result = eval(body);
	    Scope_end();
	    nlrPop();
	    return result;
	}
    }
}

oop declare(oop name, oop value)
{
    oop scope = List_last(scopes);
    int index = Scope_find(scope, name); // searches active scope only
    if (index >= 0) {
	oop old     = Scope_lookup(name);		assert(old);
	switch (getType(old)) {
	    case Variable: {
		oop oldtype = get(old, Variable,type);
		if (is(Tfunction, oldtype)) {
		    switch (getType(value)) {
			case Variable: {
			    oop valtype = get(value, Variable,type);
			    if (oldtype == valtype) return value; // function declaration
			    break;
			}
			case Function: { // replace forard declaration with actual function
			    Scope_redeclare(name, value);
			    return value;
			}
			default:
			    break;
		    }
		}
		break;
	    }
	    case Function: {
		if (is(Variable, value)) {
		    oop oldtype = get(old, Function,type);
		    oop valtype = get(old, Variable,type);
		    if (oldtype == valtype) return value; // compatible redeclaration
		}
		break;
	    }
	    default:
		break;
	}
	fatal("name '%s' redefined\n", get(name, Symbol,name));
    }
    List_append(get(scope, Scope,names ), name );
    List_append(get(scope, Scope,values), value);
    return value;
}

oop declareVariable(oop name, oop type, oop value, int isdead)
{
    assert(is(Symbol, name));
    return declare(name, newVariable(name, type, value, isdead));
}

oop declareType(oop name, oop type)
{
    return declare(name, newTypeName(name, type));
}

oop declarePrimitive(oop name, oop type, oop parameters, prim_t function)
{
    return declare(name, newPrimitive(name, type, parameters, function));
}

oop cvt_(oop obj)	{ return obj; }
oop cvtI(oop obj)	{ return newInteger((int)_integerValue(obj)); }
oop cvtP(oop obj)	{ return newPointer(t_pvoid, obj, 0); }

cvt_t converter(int tfrom, int tto)
{
    static cvt_t converters[9][9] = {
	/* void char short   int  long float double pointer array <- FROM TO -v */
	{     0,   0,    0,    0,    0,    0,     0,      0,    0 },	// void
	{     0,   0,    0,    0,    0,    0,     0,      0,    0 },	// char
	{     0,   0,    0,    0,    0,    0,     0,      0,    0 },	// short
	{     0,   0,    0, cvtI, cvtI,    0,     0,      0,    0 },	// int
	{     0,   0,    0, cvtI,    0,    0,     0,   cvt_,    0 },	// long
	{     0,   0,    0,    0,    0, cvt_,     0,      0,    0 },	// float
	{     0,   0,    0,    0,    0,    0,     0,      0,    0 },	// double
	{     0,   0,    0,    0, cvt_,    0,     0,   cvt_,    0 },	// pointer
	{     0,   0,    0,    0,    0,    0,     0,      0,    0 },	// array
    };
    if (tfrom < Tvoid || tfrom > Tarray) return 0;
    if (tto   < Tvoid || tto   > Tarray) return 0;
    return converters[tto - Tvoid][tfrom - Tvoid];
}

int isType(oop obj)
{
    type_t type = getType(obj);
    return Tvoid <= type && type <= Tfunction;
}

int typeSize(oop type)
{
    switch (getType(type)) {
	case Tvoid: 	return 1;
	case Tchar: 	return 1;
	case Tshort: 	return 2;
	case Tint: 	return 4;
	case Tlong: 	return 8;
	case Tfloat: 	return 4;
	case Tdouble: 	return 8;
	case Tpointer:	return 8; // fixme: make this a parameter
	case Tstruct: {
	    int size = get(type, Tstruct,size);
	    if (size < 0) {
		oop tag = get(type, Tstruct,tag);
		fatal("cannot determine size of incomplete struct type '%s'",
		      isNil(tag) ? "<anonymous>" : symbolName(tag));
	    }
	    return size;
	}
	case Tarray: {
	    oop target = get(type, Tarray,target);
	    if (isNil(target)) fatal("cannot determine size of incomplete array type (unknown element type)");
	    oop size   = get(type, Tarray,size);
	    if (isNil(size))   fatal("cannot determine size of incomplete array type (unknown size)");
	    return typeSize(target) * _integerValue(size);
	}
	case Tfunction:	assert(!"unimplemented");
	default:	assert(!"this cannot happen");
    }
    return 0;
}

oop incr(oop val, int amount)
{
  switch (getType(val)) {
    case Integer:	return newInteger(integerValue(val) + amount);
    case Float:	return newFloat  (  floatValue(val) + amount);
    case Pointer: {
      oop t = get(val, Pointer,type);
      oop b = get(val, Pointer,base);
      int o = get(val, Pointer,offset) + amount;
      oop p = newPointer(t, b, o);
      switch (getType(b)) {
	case Variable:
	  if (o < -1 || o > 1) fatal("pointer modified beyond base object: %s", toString(p));
	  break;
	case Memory: {
	  int limit = get(b, Memory,size) / typeSize(get(t, Tpointer,target));
	  if (o < -1 || o > limit) fatal("pointer modified beyond base object: %s", toString(p));
	  break;
	}
	default:
	  println(b);
	  assert(!"unimplemented");
	  break;
      }
      return p;
    }
    default:
      fatal("cannot increment: %s", toString(val));
  }
  return nil;
}

int toBoolean(oop arg)
{
    switch (getType(arg)) {
	case Integer:	return !!_integerValue(arg);
	case Float:	return !! integerValue(arg);
	case String:	return 1;
	case Reference:	return 1;
	case Pointer: {
	    oop base = get(arg, Pointer,base);
	    switch (getType(base)) {
		case Integer:	return !!_integerValue(base);
		case Memory:	return !!get(base, Memory,base);
		default:	fatal("cannot convert pointer base %s to boolean", getTypeName(base));
	    }
	}
	default:	fatal("cannot convert %s to boolean", getTypeName(arg));
    }
    return 0;
}

#define isTrue(O)	( toBoolean(O))
#define isFalse(O)	(!toBoolean(O))

int isNull(oop p)
{
    switch (getType(p)) {
	case Integer:	return 0 == _integerValue(p);
	case Pointer: {
	    if (t_pvoid != get(p, Pointer,type)) return 0;
	    oop base = get(p, Pointer,base);
	    switch (getType(base)) {
		case Integer:	return 0 == _integerValue(base);
		case Memory:	return 0 == get(base, Memory,base);
		default:	break;
	    }
	    break;
	}
	default: break;
    }
    return 0;
}

oop pointerType(oop arg)
{
    switch (getType(arg)) {
	case Pointer:	return get(arg, Pointer,type);
	case Array:	return get(arg, Array,type);
	default:	break;
    }
    return nil;
}

oop elementType(oop arg)
{
    switch (getType(arg)) {
	case Pointer:	return get(get(arg, Pointer,type), Tpointer,target);
	case Array:	return get(get(arg, Array,type),   Tarray,target);
	default:	break;
    }
    return nil;
}

oop pointerMemory(oop arg)
{
    oop base = nil;
    switch (getType(arg)) {
	case Pointer:	base = get(arg, Pointer,base);	break;
	case Array:	base = get(arg, Array,base);	break;
	default:	break;
    }
    if (!is(Memory, base)) return nil;
    return base;
}

char *pointerString(oop ptr)
{
    oop mem = pointerMemory(ptr);
    if (nil == mem) fatal("cannot get string from pointer: ", toString(ptr));
    char *addr = get(mem, Memory,base);
    int   size = get(mem, Memory,size);
    char *term = memchr(addr, '\0', size);
    if (!term) fatal("unterminated string: %s", toString(ptr));
    return addr;
}

oop prim_printf(int argc, oop *argv, oop env) // array
{
    if (argc < 1) fatal("printf: no format string");
    oop format = argv[0];
    if (!is(String, format)) fatal("printf: format is not a string");
    char *fmt  = get(format, String,elements);
    int   size = get(format, String,size);
    int   n    = 0;
    int   argn = 1;
    for (int i = 0;  i < size;) {
	if (fmt[i] != '%') {
	  echo:
	    putchar(fmt[i++]);
	    ++n;
	    continue;
	}
	int j = i, c = 0;
	int mod_z = 0, mod_l = 0;
	for (;;) {
	    c = fmt[++j];
	    if (!c) goto echo;
	    if (!strchr(" 0123456789#-+'.zl", c)) break;
	    if ('z' == c) ++mod_z;
	    if ('l' == c) ++mod_l;
	}
	if (!strchr("cdiouxXceEfFgGsp%", c))
	    fatal("printf: illegal conversion specifier '%c'", c);
	char buf[32];
	if (j - i >= sizeof(buf) - 1) fatal("printf: format too complex");
	int k = 0;
	while (i <= j) buf[k++] = fmt[i++];
	assert(k < sizeof(buf));
	buf[k] = 0;
	if ('%' == c) {
	    n += printf(buf, 0); // junk argument defeats gcc's -Wformat-security warning
	    continue;
	}
	if (argn >= argc) fatal("printf: too few arguments for format string");
	oop arg = argv[argn++];
	switch (c) {
	    case 'c': case 'd': case 'i': case 'o': case 'u': case 'x': case 'X': {
		if (!is(Integer, arg)) fatal("printf: argument of '%%%c' is not 'int'", c);
		long x = _integerValue(arg);
		if      (mod_z     ) n += printf(buf, (size_t)x);
		else if (mod_l == 1) n += printf(buf, (long)x);
		else if (mod_l == 2) n += printf(buf, (long long)x);
		else                 n += printf(buf, (int)x);
		continue;
	    }
	    case 'e': case 'E': case 'f': case 'F': case 'g': case 'G': {
		if (!is(Float, arg)) fatal("printf: argument of '%%%c' is not 'float'", c);
		double x = _floatValue(arg);
		n += printf(buf, x);
		continue;
	    }
	    case 's': {
		switch (getType(arg)) {
		    case String: {
			n += printf(buf, String_cString(arg));
			continue;
		    }
		    case Pointer:
		    case Array: {
			oop type = elementType(arg);
			if (t_char == type) {
			    char *addr = pointerString(arg);
			    n += printf(buf, addr);
			    continue;
			}
			break;
		    }
		    default:
			break;
		}
		fatal("printf: %%s conversion of non-string: %s", toString(arg));
		break;
	    }
	    case 'p': {
		switch (getType(arg)) {
		    case Pointer:
		    case Array: {
			buf[k-1] = 's';
			n += printf(buf, toString(arg));
			break;
		    }
		    default:
			fatal("printf: %%p conversion of non-pointer: %s", getTypeName(arg));
		}
		continue;
	    }
	}
    }
    if (argn < argc) fatal("printf: too many arguments for format string");
    return newInteger(n);
}

oop prim_assert(int argc, oop *argv, oop env) // array
{
    if (argc != 1) fatal("assert: wrong number of arguments");
    int value = toBoolean(argv[0]);
    if (!value) fatal("assertion failed\n");
    return nil;
}

oop heap = 0;

oop prim_malloc(int argc, oop *argv, oop env) // array
{
    if (argc != 1) fatal("malloc: wrong number of arguments");
    oop arg = argv[0];
    if (is(Integer,arg)) {
	size_t size = _integerValue(arg);
	if (size >= 0) {
	    if (size > 10*1024*1024)
		fatal("cowardly refusing to allocate memory of size %zd", size);
	    void *ptr = MALLOC(size);
	    if (!ptr) fatal("malloc(%zd) failed", size);
	    oop mem = newMemory(ptr, size, 1);
	    List_append(heap, mem);
	    return newPointer(t_pvoid, mem, 0);
	}
    }
    fatal("malloc: invalid argument: %s", toString(arg));
    return 0;
}

oop prim_free(int argc, oop *argv, oop env) // array
{
  if (argc != 1) fatal("free: wrong number of arguments");
  oop arg = argv[0];
  if (!is(Pointer,arg)) fatal("free: argument is not a pointer");
  oop base = get(arg, Pointer,base);
  get(arg, Pointer, isfree) = -1;
  switch (getType(base)) {
    case Integer:	fatal("attempt to free arbitrary pointer %s", toString(arg));
    case Variable:	fatal("attempt to free pointer to variable %s", toString(arg));
    case Memory: {
      if (!get(base, Memory,heap)) fatal("freed memory was not allocated in the heap: %s", toString(base));
      if ( get(base, Memory,free)) fatal("memory freed more than once: %s", toString(base));
      FREE(get(base, Memory,base));
      set(base, Memory,free, get(base, Memory,free) + 1);
      break;
    }
    default:	assert(!"this cannot happen");
  }
  return nil;
}

oop prim_exit(int argc, oop *argv, oop env) // array
{
    if (argc != 1) fatal("exit: wrong number of arguments");
    oop arg = argv[0];
    if (!is(Integer,arg)) fatal("exit: argument is not an integer");
    exit(_integerValue(arg));
    return nil;
}

oop prim_abort(int argc, oop *argv, oop env) // array
{
    if (argc != 0) fatal("abort: wrong number of arguments");
    abort();
    return nil;
}

oop prim_atoi(int argc, oop *argv, oop env) // array
{
    if (argc != 1) fatal("atoi: wrong number of arguments");
    oop arg = argv[0];
    if (!is(Pointer, arg) || t_pchar != get(arg, Pointer,type))
	fatal("atoi: illegal argument: %s", toString(arg));
    return newInteger(atoi(pointerString(arg)));
}

oop prim_sqrtf(int argc, oop *argv, oop env) // array
{
    if (argc != 1) fatal("sqrtf: wrong number of arguments");
    oop arg = argv[0];
    if (!is(Float, arg)) fatal("sqrtf: argument is not a float");
    return newFloat(sqrtf(_floatValue(arg)));
}

void declareTag(oop type)
{
    oop members = get(type, Tstruct,members);
    int size    = get(type, Tstruct,size);
    if (size < 0 && !isNil(members)) { // defining
	int offset = 0;
	oop vars = newList();
	List_do(members, vardecls) {
	    oop vtype = get(vardecls, VarDecls,type);
	    oop decls = get(vardecls, VarDecls,variables);
	    List_do(decls, decl) {
		oop mtype = makeType(vtype, decl);
		oop mname = makeName(decl);
		int msize = typeSize(mtype);
		int fragment = offset % msize;
		if (fragment) offset += msize - fragment;
		oop var = newVariable(mname, mtype, newInteger(offset), 0);
		List_append(vars, var);
		offset += msize;
	    }
	}
	set(type, Tstruct,members, vars);
	set(type, Tstruct,size,    offset);
    }
}

oop typeCheck(oop exp, oop fntype)
{
    switch (getType(exp)) {
	case Integer:	return t_int;
	case Float:	return t_float;
	case Pointer: 	break;
	case String:	return t_pchar;
	case Symbol: {
	    oop value = Scope_lookup(exp);
	    if (!value) 	fatal("undefined variable '%s'", symbolName(exp));
	    if (nil == value) 	fatal("uninitialised variable '%s'", symbolName(exp));
	    switch (getType(value)) {
		case Primitive:	return get(value, Primitive,type);
		case Function:	return get(value, Function,type);
		case Variable:	return get(value, Variable,type);

		default:
		    fatal("cannot typecheck value of type %s", getTypeName(value));
	    }
	    return nil;
	}
	case Addressof: {
	    return newTpointer(typeCheck(get(exp, Addressof,rhs), fntype));
	}
	case Dereference: {
	    oop rhs = get(exp, Dereference,rhs);
	    oop rht = typeCheck(rhs, fntype);
	    if (!is(Tpointer, rht))
		fatal("%scannot dereference '%s'",
		      tokloc(get(exp, Dereference,token)), toString(rhs));
		return get(rht, Tpointer,target);
	}
	case Cast: {
	    oop lhs = makeBaseType(get(exp, Cast,type));
	    oop rhs = get(exp, Cast,rhs);
	    set(exp, Cast,type, lhs);
	    type_t lht = getType(lhs);
	    if (Tpointer == lht && is(Integer,rhs) && !_integerValue(rhs)) {
		set(exp, Cast,converter, cvtP);
		return lhs;
	    }
	    rhs = typeCheck(get(exp, Cast,rhs), fntype);
	    cvt_t cvt = converter(getType(rhs), lht);
	    if (!cvt) fatal("cannot convert '%s' to '%s'", toString(rhs), toString(lhs));
	    set(exp, Cast,converter, cvt);
	    return lhs;
	}
	case Sizeof: {
	    oop rhs  = get(exp, Sizeof,rhs);
	    if (!isType(rhs)) rhs = typeCheck(rhs, fntype);	assert(isType(rhs));
	    set(exp, Sizeof,size, newInteger(typeSize(rhs)));
	    return t_long;
	}
	case Unary: {
	    oop rhs = get(exp, Unary,rhs);
	    oop rht = typeCheck(rhs, fntype);
	    switch (get(exp, Unary,operator)) {
		case NEG:
		    switch (getType(rht)) {
			case Tchar: case Tshort: case Tint:	return t_int;
			case Tfloat: case Tdouble:		return rht;
			default: fatal("cannot negate: %s", toString(rhs));
		    }
		case NOT:	return t_int;
		case COM:
		    switch (getType(rht)) {
			case Tint: case Tlong: return rht;
			default: fatal("cannot complement: %s", toString(rhs));
			return t_int;
		    }
		case PREINC:	return rht;
		case PREDEC:	return rht;
		case POSTINC:	return rht;
		case POSTDEC:	return rht;
	    }
	    return nil;
	}
	case Binary: {
	    oop lhs = typeCheck(get(exp, Binary,lhs), fntype);
	    oop rhs = typeCheck(get(exp, Binary,rhs), fntype);
	    switch (get(exp, Binary,operator)) {
		case MUL: {
		    if (lhs == rhs) {
			if (t_int    == lhs) return lhs;
			if (t_long   == lhs) return lhs;
			if (t_float  == lhs) return lhs;
			if (t_double == lhs) return lhs;
		    }
		    fatal("cannot multiply '%s' and '%s'", toString(lhs), toString(rhs));
		    break;
		}
		case DIV: {
		    if (lhs == rhs) {
			if (t_int    == lhs) return lhs;
			if (t_long   == lhs) return lhs;
			if (t_float  == lhs) return lhs;
			if (t_double == lhs) return lhs;
		    }
		    fatal("cannot divide '%s' and '%s'", toString(lhs), toString(rhs));
		    break;
		}
		case MOD: 	assert(!"unimplemented"); 	break;
		case ADD: {
		    if (lhs == rhs) {
			if (t_int   == lhs) return lhs;
			if (t_float == lhs) return lhs;
		    }
		    if (is(Tpointer, lhs) && t_int == rhs) {
			return lhs;
		    }
		    if (is(Tarray, lhs) && t_int == rhs) {
			return newTpointer(get(lhs, Tarray,target));
		    }
		    fatal("%scannot add '%s' and '%s'", tokloc(get(exp, Binary,token)),
			  toString(lhs), toString(rhs));
		    break;
		}
		case SUB: {
		    if (lhs == rhs) {
			if (t_int   == lhs) return lhs;
			if (t_float == lhs) return lhs;
		    }
		    if (is(Tpointer, lhs) && t_int == rhs) {
			return lhs;
		    }
		    if (is(Tpointer, lhs) && is(Tpointer, rhs)) {
			return t_long;
		    }
		    fatal("%scannot subtract '%s' and '%s'",
			  tokloc(get(exp, Binary,token)),
			  toString(lhs), toString(rhs));
		    break;
		}
		case SHL: 	return t_int;//assert(!"unimplemented"); 	break;
		case SHR: 	return t_int;//assert(!"unimplemented"); 	break;
		case LT:	return t_int;
		case LE: 	assert(!"unimplemented"); 	break;
		case GE: 	assert(!"unimplemented"); 	break;
		case GT: 	return t_int;
		case EQ: 	return t_int;
		case NE: 	return t_int;
		case BAND: 	assert(!"unimplemented"); 	break;
		case BXOR: 	assert(!"unimplemented"); 	break;
		case BOR: 	assert(!"unimplemented"); 	break;
		case LAND: 	assert(!"unimplemented"); 	break;
		case LOR: 	assert(!"unimplemented"); 	break;
	    }
	    return nil;
	}
	case Index: {
	    oop lhs = typeCheck(get(exp, Index,lhs), fntype);
	    oop rhs = typeCheck(get(exp, Index,rhs), fntype);
	    if (t_int != rhs)
		fatal("%sarray index is not 'int': %s",
		      tokloc(get(exp, Index,token)), toString(get(exp, Index,rhs)));
	    switch (getType(lhs)) {
		case Tpointer:	return get(lhs, Tpointer,target);
		case Tarray:	return get(lhs, Tarray,target);
		default: fatal("'%s' is not indexable: %s", toString(lhs), toString(exp));
	    }
	    break;
	}
	case Member: {
	    oop lhs   	= get(exp, Member,lhs);
	    oop name  	= get(exp, Member,name);
	    oop ltype 	= typeCheck(lhs, fntype);
	    oop members = nil;
	    switch (getType(ltype)) {
		case Tstruct: members = get(ltype, Tstruct,members);  break;
		default:
		    fatal("member reference to non-struct/union type '%s': %s",
			  toString(ltype), toString(lhs));
	    }
	    if (isNil(members))
		fatal("member reference to incomplete type '': %s",
		      toString(ltype), toString(lhs));
	    List_do(members, member)
		if (name == get(member, Variable,name))
		    return get(member, Variable,type);
	    fatal("no member named '%s' in '%s'", symbolName(name), toString(ltype));
	    break;
	}
	case Assign: {
	    oop lhs = typeCheck(get(exp, Assign,lhs), fntype);
	    oop rhs = typeCheck(get(exp, Assign,rhs), fntype);
	    if (lhs == rhs) return lhs;
	    int lht = getType(lhs), rht = getType(rhs);
	    if (Tpointer == lht) {
		oop target = nil;
		switch (rht) {
		    case Tpointer:  target = get(rhs, Tpointer,target);  break;
		    case Tarray:    target = get(rhs, Tarray,  target);  break;
		    default:	    goto error;
		}
		if (get(lhs, Tpointer,target) == target) return lhs;
		goto error;
	    }
	  error:
	    fatal("%sincompatible types assigning '%s' to '%s'", tokloc(get(exp, Assign,token)), toString(rhs), toString(lhs));
	    return lhs;
	}
	case If: {
	    if (t_int != typeCheck(get(exp, If,condition), fntype)) fatal("if condition is not 'int'");
	    typeCheck(get(exp, If,consequent), fntype);
	    if (nil != get(exp, If,alternate))
		typeCheck(get(exp, If,alternate), fntype);
	    return nil;
	}
	case While: {
	    oop cond = get(exp, While,condition);
	    oop body = get(exp, While,expression);
	    cond = typeCheck(cond, fntype);
	    if (t_int != cond) fatal("while condition is not 'int'");
	    typeCheck(body, fntype);
	    return nil;
	}
	case For: {
	    oop init = get(exp, For,initialiser);
	    oop cond = get(exp, For,condition);
	    oop step = get(exp, For,update);
	    oop body = get(exp, For,body);
	    Scope_begin();
	    typeCheck(init, fntype);
	    cond = typeCheck(cond, fntype);
	    if (t_int != cond && !is(Tpointer, cond)) fatal("for condition is not 'int' or '*'");
	    typeCheck(step, fntype);
	    typeCheck(body, fntype);
	    Scope_end();
	    return nil;
	}
	case Primitive: {
	    oop type       = get(exp, Primitive,type      );
	    oop name       = get(exp, Primitive,name      );
	    oop parameters = get(exp, Primitive,parameters);
	    oop ptypes     = newList();
	    oop result     = makeType(type, name);
	    name = makeName(name);
	    set(exp, Primitive,name, name);
	    set(exp, Primitive,type, result);
	    if (List_size(parameters) && t_etc == List_last(parameters)) {
		List_popLast(parameters);
		set(exp, Primitive,variadic, 1);
	    }
	    List_do(parameters, var) {
		oop ptype = makeBaseType(get(var, Variable,type));
		if (t_void == ptype && (do_index || do_size > 1))
		    fatal("illegal void parameter");
		oop pname = get(var, Variable,name);
		ptype = makeType(ptype, pname);
		pname = makeName(pname);
		set(var, Variable,name, pname);
		set(var, Variable,type, ptype);
		List_append(ptypes, ptype);
	    }
	    if (1 == List_size(ptypes) && List_last(ptypes) == t_void) {
		List_popLast(ptypes);
		List_popLast(parameters);
	    }
	    assert(isNil(fntype));
	    if (get(exp, Primitive,variadic)) List_append(ptypes, t_etc);
            fntype = newTfunction(result, ptypes);
	    set(exp, Primitive,type, fntype);
#         define _(X) if (s_##X == name) set(exp, Primitive,function, prim_##X);
	    _do_primitives(_);
#         undef _
	    if (!get(exp, Primitive,function))
		fatal("external symbol '%s' is undefined", toString(name));
	    declare(name, exp);
	    return nil;
	}
	case Function: {
	    oop type       = makeBaseType(get(exp, Function,type));
	    oop name       = get(exp, Function,name      );
	    oop parameters = get(exp, Function,parameters);
	    oop body       = get(exp, Function,body      );
	    oop ptypes     = newList();
	    oop result     = makeType(type, name);
	    name = makeName(name);
	    set(exp, Function,name, name);
	    set(exp, Function,type, result);
	    if (List_size(parameters) && t_etc == List_last(parameters)) {
		List_popLast(parameters);
		set(exp, Function,variadic, 1);
	    }
	    List_do(parameters, var) {
		oop ptype = makeBaseType(get(var, Variable,type));
		if (t_void == ptype && (do_index || do_size > 1))
		    fatal("illegal void parameter");
		oop pname = get(var, Variable,name);
		ptype = makeType(ptype, pname);
		pname = makeName(pname);
		set(var, Variable,name, pname);
		set(var, Variable,type, ptype);
		List_append(ptypes, ptype);
	    }
	    if (1 == List_size(ptypes) && List_last(ptypes) == t_void) {
		List_popLast(ptypes);
		List_popLast(parameters);
	    }
	    assert(isNil(fntype));
	    if (get(exp, Function,variadic)) List_append(ptypes, t_etc);
            fntype = newTfunction(result, ptypes);
	    set(exp, Function,type, fntype);
	    declare(name, exp);	// add function to global scope so recursive calls will work
	    Scope_begin();	// parameters
	    List_do(parameters, param) declare(get(param, Variable,name), param);
	    typeCheck(body, fntype); // block
	    Scope_end();
	    return nil;
	}
	case Block: {
	    Scope_begin();
	    oop statements = get(exp, Block,statements);
	    List_do(statements, statement) typeCheck(statement, fntype);
	    Scope_end();
	    return nil;
	}
	case Call: {
	    oop function  = get(exp, Call,function );
	    oop arguments = get(exp, Call,arguments);
	    oop tfunc     = typeCheck(function, fntype);
	    if (!is(Tfunction, tfunc))
		fatal("%scannot call %s", tokloc(get(exp, Call,token)), toString(tfunc));
	    oop  params = get(tfunc, Tfunction,parameters);
	    int  argc   = get(arguments, List,size);
	    oop *argv   = get(arguments, List,elements);
	    int  parc   = get(params, List,size);
	    oop *parv   = get(params, List,elements);
	    int  vararg = parc && (t_etc == parv[parc - 1]);
	    if ((!vararg && (argc != parc)) || (vararg && (argc < parc - 1)))
		fatal("%swrong number (%d) of arguments, expected %d",
		      tokloc(get(exp, Call,token)), argc, parc);
	    int  argn = 0;
	    while (argn < argc) {
		oop part = parv[argn];
		if (part == t_etc) break;
		oop arg  = argv[argn++];
		oop argt = typeCheck(arg, fntype);
		if (argt != part) {
		    if (is(Tpointer, argt) && t_pvoid == part) continue;
		    if (is(Tpointer, part) && t_pvoid == argt) continue;
		    fatal("cannot pass argument of type '%s' to parameter of type '%s': %s ",
			  toString(argt), toString(part), toString(exp));
		}
	    }
	    while (argn < argc) typeCheck(argv[argn++], fntype);
	    return get(tfunc, Tfunction,result);
	}
	case Return: {
	    assert(nil != fntype);
	    oop result = get(fntype, Tfunction,result);
	    oop value  = get(exp, Return,value);
	    oop vtype  = isNil(value) ? t_void : typeCheck(value, fntype);
	    if (vtype != result)
		fatal("incompatible return of %s from function returning %s",
		      toString(vtype), toString(result));
	    return result;
	}
	case VarDecls: {
	    oop base  = makeBaseType(get(exp, VarDecls,type));
	    printf("basetype:%d\n",getType(base));
		if (is(Tstruct, base)) declareTag(base);
	    oop decls = get(exp, VarDecls,variables);
		println(decls);
	    oop vars  = newList();
	    List_do(decls, decl) {
		oop init   = nil;
		oop assign = nil;
		if (is(Assign, decl)) {
		    assign = get(decl, Assign,token);
		    init   = get(decl, Assign,rhs);
		    decl   = get(decl, Assign,lhs);
		}
		oop varname = makeName(decl);
		oop vartype = makeType(base, decl);
		if (is(Tfunction, vartype)) {
		    oop ptypes = get(vartype, Tfunction,parameters);
		    if (1 == List_size(ptypes) && t_void == List_last(ptypes)) {
			List_popLast(ptypes);
			// make unique
			vartype = newTfunction(get(vartype, Tfunction,result), ptypes);
		    }
		}
		oop old = Scope_local(varname);
		if (old) { // declared
		    oop oldtype = nil;
		    switch (getType(old)) {
			case Variable: {
			    oldtype = get(old, Variable,type);
			    if (oldtype == vartype) { // identical declarations
				oop oldval = get(old, Variable,value);
				if (isNil(fntype)) // global declarations
				    if (isNil(init) || isNil(oldval)) // at most one initialiser
					continue; // redeclaration is permitted
				fatal("multiple definiton of variable '%s'", toString(varname));
			    }
			    break;
			}
			case Function:	oldtype = get(old, Function,type);	break;
			case Primitive:	oldtype = get(old, Primitive,type);	break;
			default:
			    fatal("cannot find type of declaration: %s", toString(old));
		    }
		    if (vartype == oldtype) continue;
		    fatal("identifier '%s' redefined as different type: %s -> %s",
			  toString(varname),
			  declareString(oldtype, varname),
			  declareString(vartype, varname));
		}
		if (!isNil(varname)) {
		    // do this now so that an initialiser can refer to the new variable
		    oop var = declareVariable(varname, vartype, init, 0);
		    List_append(vars, var);
		    if (!isNil(init)) {
			switch (getType(vartype)) {
			    case Tarray: {
				oop etype = get(vartype, Tarray,target);
				oop asize = get(vartype, Tarray,size);
				int isize = 0;
				if (t_char == etype && is(String, init)) {
				    isize = get(init, String,size);
				    if (isNil(asize)) ++isize; // nul terminator
				}
				else if (is(List, init)) {
				    isize = List_size(init);
				}
				if (isNil(asize)) {
				    asize   = newInteger(isize);
				    vartype = newTarray(etype, asize);
				    set(var, Variable,type, vartype); // implicitly sized array
				}
				else {
				    int na = _integerValue(asize);
				    if (isize < na) /*fatal("too few initialisers for array")*/;
				    if (isize > na) fatal("too many initialisers for array");
				}
				if (is(List, init)) {
				    List_do(init, ini) {
					oop itype = typeCheck(ini, fntype);
					if (itype != etype)
					    fatal("cannot initialise array element type '%s' with '%s'",
						  toString(etype), toString(itype));
				    }
				}
				break;
			    }
			    case Tstruct: {
				assert(is(List, init));
				oop members = get(vartype, Tstruct,members);
				int ssize   = get(members, List,size);
				int isize   = List_size(init);
				if (isize != ssize) fatal("wrong number of structure initialisers\n");
				List_do(members, member) {
				    oop ini   = List_get(init, do_index);
				    oop itype = typeCheck(ini, fntype);
				    oop mtype = get(member, Variable,type);
				    if (itype != mtype)
					fatal("incompatible types initialising member '%s'",
					      get(member, Variable,name));
				}
				break;
			    }
			    default: {
					printf("vartype:%d\n", getType(vartype));
				oop initype = typeCheck(init, fntype);
				if (is(Tpointer, vartype) && is(Integer,init) && !_integerValue(init))
				    break;
				cvt_t cvt   = converter(getType(initype), getType(vartype));
				if (!cvt) {
				    fatal("%sinitialising '%s': cannot convert '%s' to '%s'",
					  tokloc(assign),
					  toString(varname), toString(initype), toString(vartype)
					);
				}
				break;
			    }
			}
		    }
		}
	    }
	    set(exp, VarDecls,variables, vars);
	    return nil;
	}
	case TypeDecls: {
	    oop base  	  = makeBaseType(get(exp, TypeDecls,type));
	    oop decls 	  = get(exp, TypeDecls,typenames);
	    oop typenames = newList();
	    List_do(decls, decl) {
		oop name = makeName(decl);
		oop type = makeType(base, decl);
		if (is(Tfunction, type)) {
		    oop ptypes = get(type, Tfunction,parameters);
		    if (1 == List_size(ptypes) && t_void == List_last(ptypes)) {
			List_popLast(ptypes);
			type = newTfunction(get(type, Tfunction,result), ptypes);
		    }
		}
		oop old = Scope_local(name);
		if (old) { // declared
		    if (getType(old) != TypeName)
			fatal("'%s' redeclared as different kind of symbol", toString(name));
		    oop oldtype = get(old, TypeName,type);
		    if (oldtype != type)
			fatal("incompatible declarations of type '%s': %s -> %s",
			      toString(name), toString(oldtype), toString(type));
		}
		else {
		    oop typename = declareType(name, type);
		    List_append(typenames, typename);
		}
	    }
	    set(exp, TypeDecls,typenames, typenames);
	    return nil;
	}
	default:
	    break;
    }
    println(exp);
    fatal("cannot typeCheck: %s", toString(exp));
    return 0;
}

oop getPointer(oop ptr, int delta)
{
  oop base   = get(ptr, Pointer,base);
  int offset = get(ptr, Pointer,offset) + delta;
  oop type   = get(get(ptr, Pointer,type), Tpointer,target);
  int scale  = typeSize(type);
  switch (getType(base)) {
    case Variable: {
      if (offset != 0) fatal("pointer to variable no longer points to its variable: %s", toString(ptr));
      return get(base, Variable,value);
    }
    case Memory: {
	  if(get(base,Memory, free))fatal("getting freed memory was not allowed: %s", toString(base));
      void *addr = get(base, Memory,base) + offset * scale;
      assert(addr < get(base, Memory,base) + get(base, Memory,size));
      switch (getType(type)) {
	case Tchar:    	return newInteger(*(char   *)addr);
	case Tshort:   	return newInteger(*(short  *)addr);
	case Tint:     	return newInteger(*(int    *)addr);
	case Tlong:    	return newInteger(*(long   *)addr);
	case Tfloat:   	return newFloat  (*(float  *)addr);
	case Tdouble:  	return newFloat  (*(double *)addr);
	case Tstruct:   return newStruct(type, base);
	default:
	  println(ptr);
	  fatal("cannot load '%s' from memory pointer", getTypeName(type));
	  break;
      }
      break;
    }
    default:
      break;
  }
  println(ptr);
  fatal("cannot load '%s' through pointer", getTypeName(type));
  return 0;
}

oop getMemory(oop memory, int offset, oop type)
{
    int memsize = get(memory, Memory,size);
    int valsize = typeSize(type);
    if (offset           <      0) fatal("memory offset is negative");
    if (offset + valsize > memsize) fatal("memory offset out of bounds");
    void *addr = get(memory, Memory,base) + offset;
    switch (getType(type)) {
	case Tchar:    	return newInteger(*(char   *)addr);
	case Tshort:   	return newInteger(*(short  *)addr);
	case Tint:     	return newInteger(*(int    *)addr);
	case Tlong:    	return newInteger(*(long   *)addr);
	case Tfloat:   	return newFloat  (*(float  *)addr);
	case Tdouble:  	return newFloat  (*(double *)addr);
	case Tpointer: {
	    void *value = *(void **)addr;
	    oop target = get(type, Tpointer,target);
	    switch (getType(target)) {
	      case Tstruct: 	return newPointer(   type, newMemory(value, typeSize(target), 0), 0);
	      case Tchar:	return newPointer(t_pchar, newMemory(value, strlen(value)+1,  0), 0);
	      default:	break;
	    }
	    fatal("cannot load pointer to '%s' from memory", getTypeName(target));
	}
	default:	break;
    }
    fatal("cannot load '%s' from memory", getTypeName(type));
    return 0;
}

oop setMemory(oop memory, int offset, oop type, oop value)
{
    int memsize = get(memory, Memory,size);
    int valsize = typeSize(type);
    if (offset           <      0) fatal("memory offset is negative");
    if (offset + valsize > memsize) fatal("memory offset out of bounds");
    void *addr = get(memory, Memory,base) + offset;
    switch (getType(type)) {
	case Tchar:    	return newInteger(*(char   *)addr = _integerValue(value));
	case Tshort:   	return newInteger(*(short  *)addr = _integerValue(value));
	case Tint:     	return newInteger(*(int    *)addr = _integerValue(value));
	case Tlong:    	return newInteger(*(long   *)addr = _integerValue(value));
	case Tfloat:   	return newFloat  (*(float  *)addr = _floatValue(value));
	case Tdouble:  	return newFloat  (*(double *)addr = _floatValue(value));
	case Tpointer: {
	    switch (getType(value)) {
		case Integer: {
		    *(void **)addr = (void *)(intptr_t)_integerValue(value);
		    return newPointer(type, value, 0);
		}
		case Pointer: {
			if(get(value, Pointer, isfree))fatal("freed memory set");
		    oop base = get(value, Pointer,base);
		    switch (getType(base)) {
			case Memory: {
			    *(void **)addr = get(base, Memory,base);
			    return value;
			}
			default: break;
		    }
		    println(base);
		    assert(0);
		}
		default: {
		    println(value);
		    fatal("cannot store '%s' into memory", getTypeName(type));
		}
	    }
	}
	default:	break;
    }
    fatal("cannot store '%s' into memory", getTypeName(type));
    return 0;
}

oop getArray(oop array, int index)
{
    int size  = get(array, Array,size);
    if (index <     0) fatal("array index is negative");
    if (index >= size) fatal("array index out of bounds");
    oop base  = get(array, Array,base);
    oop type  = get(get(array, Array,type), Tarray,target);
    int scale = typeSize(type);
    assert(is(Memory, base));
    void *addr = get(base, Memory,base) + index * scale;
    assert(addr < get(base, Memory,base) + get(base, Memory,size));
    switch (getType(type)) {
	case Tchar:    	return newInteger(*(char   *)addr);
	case Tshort:   	return newInteger(*(short  *)addr);
	case Tint:     	return newInteger(*(int    *)addr);
	case Tlong:    	return newInteger(*(long   *)addr);
	case Tfloat:   	return newFloat  (*(float  *)addr);
	case Tdouble:  	return newFloat  (*(double *)addr);
	case Tpointer:  return getMemory(base, scale * index, type);
	default:	break;
    }
    fatal("cannot load '%s' from array", getTypeName(type));
    return 0;
}

oop setArray(oop array, int index, oop value)
{
    int size  = get(array, Array,size);
    if (index <     0) fatal("array index is negative");
    if (index >= size) fatal("array index out of bounds");
    oop base  = get(array, Array,base);
    oop type  = get(array, Array,type);
    switch (getType(type)) {
	case Tarray:	type = get(type, Tarray,target);	break;
	case Tpointer:	type = get(type, Tpointer,target);	break;
	default:	assert(0);
    }
    int scale = typeSize(type);
    assert(is(Memory, base));
    void *addr = get(base, Memory,base) + index * scale;
    assert(addr < get(base, Memory,base) + get(base, Memory,size));
    switch (getType(type)) {
	case Tchar:    	return newInteger(*(char   *)addr = _integerValue(value));
	case Tshort:   	return newInteger(*(short  *)addr = _integerValue(value));
	case Tint:     	return newInteger(*(int    *)addr = _integerValue(value));
	case Tlong:    	return newInteger(*(long   *)addr = _integerValue(value));
	case Tfloat:   	return newFloat  (*(float  *)addr = _floatValue(value));
	case Tdouble:  	return newFloat  (*(double *)addr = _floatValue(value));
	case Tpointer: {
	    setMemory(base, scale * index, type, value);
	    return value;
	}
	default:	break;
    }
    fatal("cannot store '%s' into array", getTypeName(type));
    return 0;
}

oop assign(oop lhs, oop rhs)
{
    oop dst = lhs;
    if (is(Symbol, lhs)) lhs = Scope_lookup(lhs);
    switch (getType(lhs)) {
	case Variable: {
	    oop ltype = get(lhs, Variable,type);
	    if (is(Tpointer, ltype)) {
		switch (getType(rhs)) {
		    case Integer: {
			rhs = newPointer(ltype, rhs, 0);
			break;
		    }
		    case Pointer: {
			if (get(rhs, Pointer,type) != ltype)
			    rhs = newPointer(ltype, get(rhs, Pointer,base), get(rhs, Pointer,offset));
			break;
		    }
		    case Array: {
			rhs = newPointer(ltype, get(rhs, Array,base), 0);
			break;
		    }
		    case String: {
			if (t_pchar == ltype) {
			    char *chars  = STRDUP(String_cString(rhs));
			    oop   memory = newMemory(chars, strlen(chars) + 1, 0);
			    rhs = newPointer(ltype, memory, 0);
			    break;
			}
		    } // FALL THROUGH
		    default: {
			fatal("cannot assign: %s = %s'",
			      toString(lhs), toString(rhs));
		    }
		}
	    }
	    return set(lhs, Variable,value, rhs);
	}
	case Index: {
	    oop ondex = eval(get(lhs, Index,rhs));
	    if (!is(Integer, ondex)) fatal("array index is not 'int'");
	    int index = _integerValue(ondex);
	    lhs = eval(get(lhs, Index,lhs));
	    switch (getType(lhs)) {
		case Array: return setArray(lhs, index, rhs);
		default: break;
	    }
	    break;
	}
	case Member: { // soru.name = rhs
	    oop name 	= get(lhs, Member,name);
	    oop soru 	= eval(get(lhs, Member,lhs)); // struct or union
	    oop type    = nil;
	    oop memory  = nil;
	    oop members = nil;
	    int size    = 0;
	    switch (getType(soru)) {
		case Struct:
		    type    = get(soru, Struct,type);
		    memory  = get(soru, Struct,memory);
		    members = get(type, Tstruct,members);
		    size    = get(type, Tstruct,size);
		    break;
		default:
		    fatal("this cannot happen");
		    break;
	    }
	    oop value = nil;
	    oop vtype = nil;
	    List_do(members, var) {
		if (name == get(var, Variable,name)) {
		    vtype = get(var, Variable,type);
		    value = get(var, Variable,value);
		    break;
		}
	    }
	    assert(value != nil);
	    int offset = _integerValue(value);
	    int vsize  = typeSize(vtype);
	    assert(offset + vsize <= size);
	    return setMemory(memory, offset, vtype, eval(rhs));
	}
	case Dereference: { // *<&var> = rhs, *<&const> = rhs, *<&memory> = rhs
	    oop ptr = eval(get(lhs, Dereference,rhs));
	    switch (getType(ptr)) {
		case Pointer: { // &x
			//if(get(ptr, Pointer, isfree))fatal("freed memory deref assign");
		    oop base   = get(ptr, Pointer,base);
		    int offset = get(ptr, Pointer,offset);
		    oop type   = get(get(ptr, Pointer,type), Tpointer,target);
		    int scale  = typeSize(type);
		    switch (getType(base)) {
			case Integer: { // (void *)(intptr_t)N
			    fatal("%sattempt to store into arbitrary memory location",
				  tokloc(get(lhs, Dereference,token)));
			}
			case Variable: { // &var
				oop name = get(base, Variable, name);
				if (get(base, Variable, isdead))fatal("Var '%s' that you tried to deref is already dead ",toString(name));
			    if (offset) fatal("pointer modified");
			    return set(base, Variable,value, rhs);
			}
			case Memory: {
			    int size = get(base, Memory,size);
			    if (offset < 0 || offset * scale > size - scale)
				fatal("assigning to out-of-bounds pointer");
			    void *addr = get(base, Memory,base) + offset * scale;
			    switch (getType(type)) {
				case Tchar:    	return newInteger(*(char   *)addr = _integerValue(rhs));
				case Tshort:   	return newInteger(*(short  *)addr = _integerValue(rhs));
				case Tint:     	return newInteger(*(int    *)addr = _integerValue(rhs));
				case Tlong:    	return newInteger(*(long   *)addr = _integerValue(rhs));
				case Tfloat:   	return newFloat  (*(float  *)addr = _floatValue(rhs));
				case Tdouble:  	return newFloat  (*(double *)addr = _floatValue(rhs));
				default:	break;
			    }
			    printf("ASSIGN ");  println(lhs);
			    printf("FROM ");    println(rhs);
			    fatal("cannot store '%s' through pointer", getTypeName(type));
			}
			default: break;
		    }
		}
		default: break;
	    }
	}
	default: break;
    }
    if (dst == lhs) fatal("cannot assign to: %s", toString(lhs));
    fatal("invalid rvalue '%s' assigning to: %s", toString(lhs), toString(dst));
    return 0;
}

int equal(oop a, oop b)
{
    if (a == b) return 1;
    type_t ta = getType(a), tb = getType(b);
    if (ta == tb) {
	switch (getType(a)) {
	    case Integer:	return _integerValue(a) == _integerValue(b);
	    case Float:		return _floatValue(a) == _floatValue(b);
	    case Pointer:	return get(a, Pointer,base) == get(b, Pointer,base);
	    default:		break;
	}
	fatal("cannot compare %ss", getTypeName(a));
    }
    if (is(Pointer, a) && is(Integer, b)) {
	oop base = get(a, Pointer,base);
	if (is(Integer, base)) {
	    oop type   = get(a, Pointer,type);
	    int offset = get(a, Pointer,offset);
	    int scale  = typeSize(get(type, Tpointer,target));
	    return _integerValue(base) + offset * scale == _integerValue(b);
	}
	return 0;
    }

    if (is(Array, a) && is(Pointer, b)) {
	oop ba = get(a, Array,base), bb = get(b, Pointer,base);
	return (ba == bb) && (get(b, Pointer,offset) == 0);
    }

    if (is(Pointer, a) && is(Array, b)) return equal(b, a);

    fatal("cannot compare %s with %s", getTypeName(a), getTypeName(b));
    return 0;
}

int compare(oop a, oop b)
{
# define CMP(A, B) ((A) < (B) ? -1 : (A) > (B) ? 1 : 0)
    if (a == b) return 0;
    type_t ta = getType(a), tb = getType(b);
    if (ta == tb) {
	switch (ta) {
	    case Integer:	return CMP(_integerValue(a), _integerValue(b));
	    case Float:		return CMP(  _floatValue(a),   _floatValue(b));
	    case Pointer: {
		oop ba = get(a, Pointer,base),   bb = get(b, Pointer,base);
		// BUG -- this should report an illegal comparison
		if (ba != bb) {
		  fatal("illegal comparison between pointers to different objects: %s and %s\n", toString(a), toString(b));
		  return CMP((intptr_t)ba, (intptr_t)bb);
		}
		int oa = get(a, Pointer,offset), ob = get(b, Pointer,offset);
		return CMP(oa, ob);
	    }
	    default:		break;
	}
	fatal("cannot compare %ss", getTypeName(a));
    }
    else {
	if (is(Pointer, a) && is(Integer, b)) {
	    oop base = get(a, Pointer,base);
	    if (is(Integer, base)) {
		oop type   = get(a, Pointer,type);
		int offset = get(a, Pointer,offset);
		int scale  = typeSize(get(type, Tpointer,target));
		return _integerValue(base) + offset * scale == _integerValue(b);
	    }
	    return 0;
	}
    }
    fatal("cannot compare %s with %s", getTypeName(a), getTypeName(b));
    return 0;
# undef CMP
}

void randomise(unsigned char *mem, size_t size)
{
    static unsigned lfsr = 0xC4E1u;
    for (int i = 0;  i < size;  ++i) {
	mem[i] = lfsr;
	lfsr >>= 1;
	if (lfsr & 1) lfsr ^= 0xB400;
    }
}

oop castPointer(oop pointer, oop type)
{
    oop target = get(type, Tpointer,target);
    int tscale = typeSize(target);
    int pscale = typeSize(get(get(pointer, Pointer,type), Tpointer,target));
    int offset = get(pointer, Pointer,offset) * pscale / tscale;
    return newPointer(type, get(pointer, Pointer,base), offset);
}

void initialiseVariable(oop var, int local)
{
    oop (*evaluate)(oop) = local ? eval : preval;
    oop type  = get(var, Variable,type);
    oop init  = get(var, Variable,value);
    switch (getType(type)) {
	case Tfunction: break;
	case Tarray: {
	    oop   target  = get(type, Tarray,target);
	    int   size    = _integerValue(get(type, Tarray,size));
	    int   memsize = typeSize(target) * size;
	    void *mem     = CALLOC(size, typeSize(target));
	    oop   memory  = newMemory(mem, memsize, 0);
	    oop   value   = newArray(type, memory, size);
	    if (isNil(init)) { // size and types checked during typeCheck
		if (local)
		    randomise(mem, memsize);
	    }
	    else { // size and types checked during typeCheck
		if (is(String, init)) {
		    int   isize = get(init, String,size);		assert(isize <= size);
		    char *chars = get(init, String,elements);
		    for (int i = 0;  i < isize;  ++i)
			setArray(value, i, newInteger(chars[i]));
		    if (isize < size)
			setArray(value, isize, newInteger(0));
		}
		else {
		    List_do(init, ini) {
			setArray(value, do_index, evaluate(ini));
		    }
		}
	    }
	    set(var, Variable,value, value);
	    break;
	}
	case Tstruct: {
	    int   size   = get(type, Tstruct,size);
	    void *mem    = CALLOC(1, size);
	    oop   memory = newMemory(mem, size, 0);
	    oop   value  = newStruct(type, memory);
	    if (isNil(init)) {
		if (local)
		    randomise(mem, size);
	    }
	    else { // size and types checked during typeCheck
		oop members = get(type, Tstruct,members);
		List_do(members, member) {
		    int offset = _integerValue(get(member, Variable,value));
		    oop type   = get(member, Variable,type);
		    oop inival = evaluate(List_get(init, do_index));
		    setMemory(memory, offset, type, inival);
		}
	    }
	    set(var, Variable,value, value);
	    break;
	}
	case Tpointer: {
	    oop value = isNil(init) ? nil : evaluate(init);
	    switch (getType(value)) {
		case Undefined: {
		    set(var, Variable,value, nil);
		    break;
		}
		case Integer: {
		    if (_integerValue(value)) fatal("storing non-zero integer into pointer");
		    value = newPointer(type, value, 0);
		    set(var, Variable,value, value);
		    break;
		}
		case String: {
		    if (type != t_pchar) fatal("cannot initialise '%s' with string literal", toString(type));
		    value = newPointer(type, value, 0);
		    set(var, Variable,value, value);
		    break;
		}
		case Pointer: {
		    oop vtype = get(value, Pointer,type);
		    if (type != vtype) {
			if (vtype != t_pvoid || !isNull(value))
			    fatal("cannot convert non-NULL pointer '%s' to '%s'", toString(vtype), toString(type));
			value = castPointer(value, type);
		    }
		    set(var, Variable,value, castPointer(value, type));
		    break;
		}
		default:
		    println(value);
		    fatal("cannot initialise pointer with %s", getTypeName(value));
		    break;
	    }
	}
	default: {
	    if (!isNil(init)) set(var, Variable,value, evaluate(init));
	    break;
	}
    }
}

oop eval(oop exp)
{
    static int depth = 0;
# define ENTER		++depth
# define RETURN(X)	do { --depth; return (X); } while (0)
    if (opt_v > 2) { printf("EVAL  "); printiln(exp, depth); }
    ENTER;
    switch (getType(exp)) {
	case Undefined:	assert(!"this cannot happen");
	case Input:	assert(!"this cannot happen");
	case Token:	assert(!"this cannot happen");
	case Integer:	RETURN(exp);
	case Float:	RETURN(exp);
	case Pointer:	RETURN(exp);
	case Array:	RETURN(exp);
	case Struct:	RETURN(exp);
	case Symbol: {
	    oop value = Scope_lookup(exp);
	    if (!value) 	fatal("'%s' is undefined\n",     get(exp, Symbol,name));
	    switch (getType(value)) {
		case Variable: {
		    value = get(value, Variable,value);
		    if (isNil(value)) fatal("use of uninitialised variable '%s'", get(exp, Symbol,name));
		    RETURN(value);
		}
		case Function:	RETURN(value);
		case Primitive:	RETURN(value);
		default:	fatal("cannot eval: %s", toString(value));
	    }
	    break;
	}
	case Pair:	assert(!"this cannot happen");
	case String:	RETURN(exp);
	case List: 	assert(!"this cannot happen");
	case Memory:	assert(!"this cannot happen");
	case Primitive:	RETURN(exp);
	case Reference: RETURN(exp);
	case Closure:	RETURN(exp);
	case Call: {
 	    oop fun  = eval(get(exp, Call,function));
 	    oop args = get(exp, Call,arguments);
 	    RETURN(apply(fun, args, nil));
	}
	case Block: {
	    Object  *stmts  = get(exp, Block,statements);
	    int      size   = get(stmts, List,size);
	    oop *elts   = get(stmts, List,elements);
	    Object  *result = nil;
	    Scope_begin();
	    switch (nlrPush()) { // longjmp occurred
		case NLR_INIT:     break;
		case NLR_RETURN:   Scope_end();  --depth;  nlrReturn(NLR_RETURN,   nlrPop());
		case NLR_CONTINUE: Scope_end();  --depth;  nlrReturn(NLR_CONTINUE, nlrPop());
		case NLR_BREAK:	   Scope_end();  --depth;  nlrReturn(NLR_BREAK,    nlrPop());
	    }
	    for (int i = 0;  i < size;  ++i) {
		result = eval(elts[i]);
	    }
	    Scope_end();
	    nlrPop();
	    RETURN(result);
	}
	case Addressof: {
	    oop rhs = get(exp, Addressof,rhs);
	    switch (getType(rhs)) {
		case Symbol: {
		    rhs = Scope_lookup(rhs);
		    if (!rhs) assert(!"this cannot happen");
		    switch (getType(rhs)) {
			case Variable: {
			    oop type = get(rhs, Variable,type);
			    if (is(Tarray,type)) RETURN(get(rhs, Variable,value));
			    RETURN(newPointer(newTpointer(get(rhs, Variable,type)), rhs, 0));
			}
			default:
			    break;
		    }
		    break;
		}
		case Index: {
		    oop ondex = eval(get(rhs, Index,rhs));
		    if (!is(Integer, ondex))
			fatal("%sarray index is not 'int'", tokloc(get(rhs, Index,token)));
		    int index = _integerValue(ondex);
		    oop lhs = eval(get(rhs, Index,lhs));
		    switch (getType(lhs)) {
			case Array: {
			    oop type = get(lhs, Array,type);
			    oop base = get(lhs, Array,base);	// xxx check index against size
			    RETURN(newPointer(newTpointer(get(type, Tarray,target)), base, index));
			}
			default: break;
		    }
		    break;
		}
		default:
		    break;
	    }
	    fatal("%scannot take address: %s", tokloc(get(exp, Addressof,token)), toString(exp));
	    break;
	}
	case Dereference: {
	    oop rhs = get(exp, Dereference,rhs);
	    rhs = eval(rhs);
	    switch (getType(rhs)) {
	      case Pointer:	{
			//if(get(rhs, Pointer, isfree))fatal("freed memory deref/eval");
			RETURN(getPointer(rhs, 0));
		}
		default:	break;
	    }
	    println(rhs);
	    assert(!"cannot dereference\n");
	    exit(1);
	    break;
	}
	case Sizeof: {
	    RETURN(get(exp, Sizeof,size));
	}
	case Unary: {
	    unary_t op  = get(exp, Unary,operator);
	    oop     rhs = get(exp, Unary,rhs);
	    switch (op) {
		case PREINC:
		case PREDEC:
		case POSTINC:
		case POSTDEC: {
		    if (is(Symbol, rhs)) {
			rhs = Scope_lookup(rhs);
			switch (getType(rhs)) {
			    case Variable: {
				oop value  = get(rhs, Variable,value);
				oop result = value;
				switch (op) {
				    case PREINC:  result = value = incr(value,  1);		break;
				    case PREDEC:  result = value = incr(value, -1);		break;
				    case POSTINC: result = value;  value = incr(value,  1);	break;
				    case POSTDEC: result = value;  value = incr(value, -1);	break;
				    default:	  assert("!this cannot happen");
				}
				set(rhs, Variable,value, value);
				RETURN(result);
			    }
			    default:  break;
			}
		    }
		    fatal("%sillegal increment operation: %s",
			  tokloc(get(exp, Unary,token)), toString(exp));
		}
		case NEG:
		case NOT:
		case COM: {
		    rhs = eval(rhs);
		    switch (op) {
			case NEG:	RETURN( is(Float, rhs)
						? newFloat  (-floatValue  (rhs))
						: newInteger(-integerValue(rhs)) );
			case NOT:	RETURN(isFalse(rhs) ? true : false);
			case COM:	RETURN(newInteger(~integerValue(rhs)));
			default:	break;
		    }
		}
	    }
	    assert("!this cannot happen");
	    break;
	}
	case Binary: {
	    oop lhs = get(exp, Binary,lhs);
	    oop rhs = get(exp, Binary,rhs);
	    switch (get(exp, Binary,operator)) {
		case LAND:   RETURN(isFalse(eval(lhs)) ? false : eval(rhs));
		case LOR:    RETURN(isTrue (eval(lhs)) ? true  : eval(rhs));
		default: {
		    lhs = eval(lhs);
		    rhs = eval(rhs);
		    if (Float == getType(lhs) || Float == getType(rhs)) { // floating point result
			switch (get(exp, Binary,operator)) {
			    case MUL: 	RETURN(FBINOP(lhs, * , rhs));
			    case DIV: 	RETURN(FBINOP(lhs, / , rhs));
			    case MOD: 	RETURN(newFloat(fmod(floatValue(lhs), floatValue(rhs))));
			    case ADD: 	RETURN(FBINOP(lhs, + , rhs));
			    case SUB: 	RETURN(FBINOP(lhs, - , rhs));
			    case SHL: 	RETURN(IBINOP(lhs, <<, rhs));
			    case SHR: 	RETURN(IBINOP(lhs, >>, rhs));
			    case LT: 	RETURN(FRELOP(lhs, < , rhs));
			    case LE: 	RETURN(FRELOP(lhs, <=, rhs));
			    case GE: 	RETURN(FRELOP(lhs, >=, rhs));
			    case GT: 	RETURN(FRELOP(lhs, > , rhs));
			    case EQ: 	RETURN(FRELOP(lhs, == , rhs));
			    case NE: 	RETURN(FRELOP(lhs, !=, rhs));
			    case BAND: 	RETURN(IBINOP(lhs, & , rhs));
			    case BXOR: 	RETURN(IBINOP(lhs, ^ , rhs));
			    case BOR: 	RETURN(IBINOP(lhs, | , rhs));
			    case LAND:
			    case LOR:
				break;
			}
		    }
		    else { // non-float result
			switch (get(exp, Binary,operator)) {
			    case MUL: 	RETURN(IBINOP(lhs, * , rhs));
			    case DIV: 	RETURN(IBINOP(lhs, / , rhs));
			    case MOD: 	RETURN(IBINOP(lhs, % , rhs));
			    case ADD: {
				if (is(Pointer, lhs) && is(Integer, rhs)) {
				    oop type   = get(lhs, Pointer,type);
				    oop base   = get(lhs, Pointer,base);
				    int offset = get(lhs, Pointer,offset);
				    offset += _integerValue(rhs);
				    RETURN(newPointer(type, base, offset));
				}
				if (is(Array, lhs) && is(Integer, rhs)) {
				    oop type = newTpointer(get(get(lhs, Array,type), Tarray,target));
				    oop ptr  = newPointer(type, get(lhs, Array,base), _integerValue(rhs));
				    RETURN(ptr);
				}
				RETURN(IBINOP(lhs, + , rhs));
			    }
			    case SUB: 	RETURN(IBINOP(lhs, - , rhs));
			    case SHL: 	RETURN(IBINOP(lhs, <<, rhs));
			    case SHR: 	RETURN(IBINOP(lhs, >>, rhs));
			    case LT: 	RETURN(compare(lhs, rhs) <  0 ? true : false);
			    case LE: 	RETURN(compare(lhs, rhs) <= 0 ? true : false);
			    case GE: 	RETURN(compare(lhs, rhs) >= 0 ? true : false);
			    case GT: 	RETURN(compare(lhs, rhs) >  0 ? true : false);
			    case EQ:	RETURN(equal(lhs, rhs) ? true : false);
			    case NE:	RETURN(equal(lhs, rhs) ? false : true);
			    case BAND: 	RETURN(IBINOP(lhs, & , rhs));
			    case BXOR: 	RETURN(IBINOP(lhs, ^ , rhs));
			    case BOR: 	RETURN(IBINOP(lhs, | , rhs));
			    case LAND:
			    case LOR:
				break;
			}
		    }
		}
	    }
	    assert(!"this cannot happen");
	    break;
	}
	case Index: {
	    oop ondex = eval(get(exp, Index,rhs));
	    if (!is(Integer, ondex)) fatal("array index is not 'int'");
	    int index = _integerValue(ondex);
	    oop lhs = eval(get(exp, Index,lhs));
	    switch (getType(lhs)) {
	      case Array: 	RETURN(getArray(lhs, index));
	      case Pointer: 	RETURN(getPointer(lhs, index));
	      default: break;
	    }
	    println(lhs);
	    assert(0);
	    break;
	}
	case Member: {
	    oop soru 	= eval(get(exp, Member,lhs)); // struct or union
	    oop name 	= get(exp, Member,name);
	    oop type    = nil;
	    oop memory  = nil;
	    oop members = nil;
	    int size    = 0;
	    switch (getType(soru)) {
		case Struct:
		    type    = get(soru, Struct,type);
		    memory  = get(soru, Struct,memory);
		    members = get(type, Tstruct,members);
		    size    = get(type, Tstruct,size);
		    break;
		default:
		    fatal("this cannot happen");
		    break;
	    }
	    oop value = nil;
	    oop vtype = nil;
	    List_do(members, var) {
		if (name == get(var, Variable,name)) {
		    vtype = get(var, Variable,type);
		    value = get(var, Variable,value);
		    break;
		}
	    }
	    assert(value != nil);
	    int offset = _integerValue(value);
	    int vsize  = typeSize(vtype);
	    assert(offset + vsize <= size);
	    RETURN(getMemory(memory, offset, vtype));
	}
	case Assign: {
	    RETURN(assign(get(exp, Assign,lhs), eval(get(exp, Assign,rhs))));
	}
	case Cast: {
	    cvt_t cvt = get(exp, Cast,converter);		assert(cvt);
	    oop  type = get(exp, Cast,type);
	    oop   rhs = eval(get(exp, Cast,rhs));
	    rhs = cvt(rhs);
	    switch (getType(type)) {
		case Tpointer: {
		    if (is(Pointer,rhs)) RETURN(castPointer(rhs, type));
		    default: break;
		}
	    }
	    RETURN(cvt(rhs));
	}
	case While: {
	    oop cond   = get(exp, While,condition);
	    oop expr   = get(exp, While,expression);
	    oop result = nil;
	    switch (nlrPush()) {
		case NLR_INIT:		break;
		case NLR_RETURN:	--depth;  nlrReturn(NLR_RETURN, nlrPop()); // propagate upwards
		case NLR_CONTINUE:	break;
		case NLR_BREAK:		--depth;  return nlrPop();
	    }
	    while (isTrue(eval(cond))) {
		result = eval(expr);
	    }
	    nlrPop();
	    RETURN(result);
	}
	case For: {
	    oop init = get(exp, For,initialiser);
	    oop cond = get(exp, For,condition);
	    oop step = get(exp, For,update);
	    oop body = get(exp, For,body);
	    Scope_begin();
	    switch (nlrPush()) {
		case NLR_INIT:		break;
		case NLR_RETURN:	--depth;  Scope_end();  nlrReturn(NLR_RETURN, nlrPop());
		case NLR_CONTINUE:	goto continued;
		case NLR_BREAK:		goto broken;
	    }
	    eval(init);
	    while (isTrue(eval(cond))) {
		eval(body);
	      continued:
		eval(step);
	    }
	  broken:
	    Scope_end();
	    nlrPop();
	    RETURN(nil);
	}
	case If: {
	    oop cond   = get(exp, If,condition);
	    oop conseq = get(exp, If,consequent);
	    oop altern = get(exp, If,alternate);
	    if (isTrue(eval(cond))) eval(conseq);
	    else if (!isNil(altern)) eval(altern);
	    RETURN(nil);
	}
	case Return: {
	    --depth;
	    nlrReturn(NLR_RETURN, eval(get(exp, Return,value)));
	    break;
	}
	case Continue: {
	    --depth;
	    nlrReturn(NLR_CONTINUE, nil);
	    break;
	}
	case Break: {
	    --depth;
	    nlrReturn(NLR_BREAK, nil);
	    break;
	}
	case Tvoid:	assert(!"unimplemented");	break;
	case Tchar:	assert(!"unimplemented");	break;
	case Tshort:	assert(!"unimplemented");	break;
	case Tint:	assert(!"unimplemented");	break;
	case Tlong:	assert(!"unimplemented");	break;
	case Tfloat:	assert(!"unimplemented");	break;
	case Tdouble:	assert(!"unimplemented");	break;
	case Tpointer:	assert(!"unimplemented");	break;
	case Tarray:	assert(!"unimplemented");	break;
	case Tstruct:	assert(!"unimplemented");	break;
	case Tfunction:	assert(!"unimplemented");	break;
	case Tetc:	assert(!"unimplemented");	break;
	case VarDecls: {
	    // declareVariables(exp);
	    List_do(get(exp, VarDecls,variables), var) {
		oop name = get(var, Variable,name);
		var = newVariable(name, get(var, Variable,type), get(var, Variable,value),0);
		declare(name, var);
		initialiseVariable(var, 1);
	    }
	    RETURN(nil);
	}
	case TypeDecls: { // local typenames only used within typeCheck() and can be ignored here
	    RETURN(nil);
	}
	case Scope:	break;
	case TypeName:	break;
	case Variable:	break;
	case Constant:	break;
	case Function:  break;
    }
    println(exp);
    assert(!"this cannot happen");
    RETURN(0);
# undef ENTER
# undef LEAVE
}

// pre-evaluate a top-level declaration, definition, or constant expression

oop preval(oop exp)
{
    if (opt_v > 2) { printf("PREVAL  "); println(exp); }
    switch (getType(exp)) {
	case Undefined:		return exp;
	case Input:		break;
	case Token:		break;
	case Integer:		return exp;
	case Float:		return exp;
	case Pointer:		return exp;
	case Array:		return exp;
	case Struct:		return exp;
	case Symbol:		break;
	case Pair:		break;
	case String:		break;
	case List:		break;
	case Memory:		break;
	case Primitive:		return exp;
	case Reference:		break;
	case Closure:		break;
	case Call:		break;
	case Block:		break;
	case Addressof:		break;
	case Dereference:	break;
	case Sizeof:		return get(exp, Sizeof,size);
	case Unary: {
	    unary_t op  = get(exp, Unary,operator);
	    oop     rhs = get(exp, Unary,rhs);
	    switch (op) {
		case PREINC:
		case PREDEC:
		case POSTINC:
		case POSTDEC: {
		    if (is(Symbol, rhs)) {
			rhs = Scope_lookup(rhs);
			switch (getType(rhs)) {
			    case Variable: {
				oop value  = get(rhs, Variable,value);
				oop result = value;
				switch (op) {
				    case PREINC:  result = value = incr(value,  1);		break;
				    case PREDEC:  result = value = incr(value, -1);		break;
				    case POSTINC: result = value;  value = incr(value,  1);	break;
				    case POSTDEC: result = value;  value = incr(value, -1);	break;
				    default:	  assert("!this cannot happen");
				}
				set(rhs, Variable,value, value);
				return result;
			    }
			    default:  break;
			}
		    }
		    fatal("%sillegal increment operation: %s",
			  tokloc(get(exp, Unary,token)), toString(exp));
		}
		case NEG:
		case NOT:
		case COM: {
		    rhs = preval(rhs);
		    switch (op) {
			case NEG:	return ( is(Float, rhs)
						 ? newFloat  (-floatValue  (rhs))
						 : newInteger(-integerValue(rhs)) );
			case NOT:	return isFalse(rhs) ? true : false;
			case COM:	return newInteger(~integerValue(rhs));
			default:	break;
		    }
		}
	    }
	    assert("!this cannot happen");
	    break;
	}
	case Binary: {
	    oop lhs = get(exp, Binary,lhs);
	    oop rhs = get(exp, Binary,rhs);
	    switch (get(exp, Binary,operator)) {
		case LAND:   return isFalse(preval(lhs)) ? false : preval(rhs);
		case LOR:    return isTrue (preval(lhs)) ? true  : preval(rhs);
		default: {
		    lhs = preval(lhs);
		    rhs = preval(rhs);
		    if (Float == getType(lhs) || Float == getType(rhs)) { // floating point result
			switch (get(exp, Binary,operator)) {
			    case MUL: 	return FBINOP(lhs, * , rhs);
			    case DIV: 	return FBINOP(lhs, / , rhs);
			    case MOD: 	return newFloat(fmod(floatValue(lhs), floatValue(rhs)));
			    case ADD: 	return FBINOP(lhs, + , rhs);
			    case SUB: 	return FBINOP(lhs, - , rhs);
			    case SHL: 	return IBINOP(lhs, <<, rhs);
			    case SHR: 	return IBINOP(lhs, >>, rhs);
			    case LT: 	return FRELOP(lhs, < , rhs);
			    case LE: 	return FRELOP(lhs, <=, rhs);
			    case GE: 	return FRELOP(lhs, >=, rhs);
			    case GT: 	return FRELOP(lhs, > , rhs);
			    case EQ: 	return FRELOP(lhs, == , rhs);
			    case NE: 	return FRELOP(lhs, !=, rhs);
			    case BAND: 	return IBINOP(lhs, & , rhs);
			    case BXOR: 	return IBINOP(lhs, ^ , rhs);
			    case BOR: 	return IBINOP(lhs, | , rhs);
			    case LAND:
			    case LOR:
				break;
			}
		    }
		    else { // non-float result
			switch (get(exp, Binary,operator)) {
			    case MUL: 	return IBINOP(lhs, * , rhs);
			    case DIV: 	return IBINOP(lhs, / , rhs);
			    case MOD: 	return IBINOP(lhs, % , rhs);
			    case ADD: {
				if (is(Pointer, lhs) && is(Integer, rhs)) {
				    oop type   = get(lhs, Pointer,type);
				    oop base   = get(lhs, Pointer,base);
				    int offset = get(lhs, Pointer,offset);
				    offset += _integerValue(rhs);
				    return newPointer(type, base, offset);
				}
				if (is(Array, lhs) && is(Integer, rhs)) {
				    oop type = newTpointer(get(get(lhs, Array,type), Tarray,target));
				    oop ptr  = newPointer(type, get(lhs, Array,base), _integerValue(rhs));
				    return ptr;
				}
				return IBINOP(lhs, + , rhs);
			    }
			    case SUB: 	return IBINOP(lhs, - , rhs);
			    case SHL: 	return IBINOP(lhs, <<, rhs);
			    case SHR: 	return IBINOP(lhs, >>, rhs);
			    case LT: 	return compare(lhs, rhs) <  0 ? true : false;
			    case LE: 	return compare(lhs, rhs) <= 0 ? true : false;
			    case GE: 	return compare(lhs, rhs) >= 0 ? true : false;
			    case GT: 	return compare(lhs, rhs) >  0 ? true : false;
			    case EQ:	return equal(lhs, rhs) ? true : false;
			    case NE:	return equal(lhs, rhs) ? false : true;
			    case BAND: 	return IBINOP(lhs, & , rhs);
			    case BXOR: 	return IBINOP(lhs, ^ , rhs);
			    case BOR: 	return IBINOP(lhs, | , rhs);
			    case LAND:
			    case LOR:
				break;
			}
		    }
		}
	    }
	    assert(!"this cannot happen");
	    break;
	}


	case Index:		break;
	case Member:		break;
	case Assign:		break;
	case Cast:		break;
	case While:		break;
	case For:		break;
	case If:		break;
	case Return:		break;
	case Continue:		break;
	case Break:		break;
	case Tvoid:		break;
	case Tchar:		break;
	case Tshort:		break;
	case Tint:		break;
	case Tlong:		break;
	case Tfloat:		break;
	case Tdouble:		break;
	case Tpointer:		break;
	case Tarray:		break;
	case Tstruct:		break;
	case Tfunction:		break;
	case Tetc:		break;
	case VarDecls: {
	    List_do(get(exp, VarDecls,variables), var) {
		initialiseVariable(var, 0);
	    }
	    return nil;
	}
	case TypeDecls: {
	    oop types = get(exp, TypeDecls,typenames);
	    List_do(types, type) {
		assert(Scope_lookup(get(type, TypeName,name)));
	    }
	    return nil;
	}
	case Scope:	break;
	case TypeName:	break;
	case Variable:	break;
	case Constant:	break;
	case Function: {
	    assert(Scope_lookup(get(exp, Function,name)));
	    return exp;
	}
    }
    println(exp);
    assert(!"this cannot happen");
    return 0;
}

enum opcode_t { iHALT = 0, iPUSH, iPOP,
    iNOT, iCOM, iNEG, iDEREF, iINDEX,
    iMUL, iDIV, iMOD, iADD, iSUB, iSHL, iSHR,
    iLT, iLE, iGE, iGT, iEQ, iNE,
    iAND, iXOR, iOR,
    iGETGVAR, iSETGVAR,
    iCLOSE,
    iCALL, iRETURN,
    iJMP, iJMPF,
};

oop stackError(char *reason)
{
    printf("stack %s\n", reason);
    exit(1);
    return nil;
}

void disassemble(oop program)
{
    oop *code = get(program, List,elements);
    int      size = get(program, List,size);
    int      pc   = 0;
    while (pc < size) {
	printf("%04d", pc);
	int opcode = _integerValue(code[pc++]);
	printf(" %02d\t", opcode);
	switch (opcode) {
	    case iHALT:		printf("HALT\n");				break;
	    case iPUSH:		printf("PUSH\t");	println(code[pc++]);	break;
	    case iPOP:		printf("POP\n");				break;
	    case iNOT:		printf("NOT\n");				break;
	    case iCOM:		printf("COM\n");				break;
	    case iNEG:		printf("NEG\n");				break;
	    case iDEREF:	printf("DEREF\n");				break;
	    case iINDEX:	printf("INDEX\n");				break;
	    case iMUL:		printf("MUL\n");				break;
	    case iDIV:		printf("DIV\n");				break;
	    case iMOD:		printf("MOD\n");				break;
	    case iADD:		printf("ADD\n");				break;
	    case iSUB:		printf("SUB\n");				break;
	    case iSHL:		printf("SHL\n");				break;
	    case iSHR:		printf("SHR\n");				break;
	    case iLT:		printf("LT\n");					break;
	    case iLE:		printf("LE\n");					break;
	    case iGE:		printf("GE\n");					break;
	    case iGT:		printf("GT\n");					break;
	    case iEQ:		printf("EQ\n");					break;
	    case iNE:		printf("NE\n");					break;
	    case iAND:		printf("AND\n");				break;
	    case iXOR:		printf("XOR\n");				break;
	    case iOR:		printf("OR\n");					break;
	    case iGETGVAR:	printf("GETGVAR\t");  	println(code[pc++]);	break;
	    case iSETGVAR:	printf("SETGVAR\t");  	println(code[pc++]);	break;
	    case iCLOSE:	printf("CLOSE\t");	println(code[pc++]);	break;
	    case iCALL:		printf("CALL\t");	println(code[pc++]);	break;
	    case iRETURN:	printf("RETURN\n");				break;
	    case iJMP:		printf("JMP\t");	println(code[pc++]);	break;
	    case iJMPF:		printf("JMPF\t");	println(code[pc++]);	break;
	}
    }
}


oop execute(oop program)
{
    oop *code = get(program, List,elements);
    int pc = 0;

    oop stack[32];
    int sp = 32; // clear the stack

    oop env = nil;

    struct Frame {
	Object  *env;
	oop *code;
	int      pc;
    } frames[32];
    int fp = 32;

# define push(O)	(sp >  0 ? stack[--sp] = (O) : stackError("overflow"))
# define pop()		(sp < 32 ? stack[sp++] : stackError("underflow"))
# define top		(stack[sp])

    for (;;) {
	oop insn = code[pc++];
	switch ((enum opcode_t)_integerValue(insn)) {
	    case iHALT: {
		if (sp < 31) fatal("%d items on stack at end of execution", 32-sp);
		if (sp < 32) return stack[sp];
		fatal("stack empty at end of execution");
		return nil;
	    }
	    case iPUSH: {
		oop operand = code[pc++];
		push(operand);
		continue;
	    }
	    case iPOP: {
		pop();
		continue;
	    }
	    case iNOT: {
		top = (isFalse(top) ? true : false);
		continue;
	    }
	    case iCOM: {
		top = newInteger(~integerValue(top));
		continue;
	    }
	    case iNEG: {
		top = is(Float, top) ? newFloat(-floatValue(top)) : newInteger(-integerValue(top));
		continue;
	    }
	    case iDEREF: {
		assert(!"unimplemented");
		continue;
	    }
	    case iINDEX: {
		assert(!"unimplemented");
		continue;
	    }
#          define BINOP(OP) {									\
		    oop rhs = pop(), lhs = pop();						\
		    if (is(Float, lhs) || is(Float, rhs))	push(FBINOP(lhs, OP, rhs));	\
		    else					push(IBINOP(lhs, OP, rhs));	\
		    continue;									\
		}
	    case iMUL: BINOP(*);
	    case iDIV: BINOP(/);
	    case iMOD: {
		oop rhs = pop(), lhs = pop();
		if (is(Float, lhs) || is(Float, rhs))
		    push(newFloat(fmod(floatValue(lhs), floatValue(rhs))));
		else
		    push(IBINOP(lhs, %, rhs));
		continue;
	    }
	    case iADD: BINOP(+);
	    case iSUB: BINOP(-);
#          undef BINOP
#          define BINOP(OP) {				\
		    oop rhs = pop(), lhs = pop();	\
		    push(IBINOP(lhs, OP, rhs));		\
		    continue;				\
		}
	    case iSHL:	BINOP(<<);
	    case iSHR:	BINOP(>>);
	    case iAND:	BINOP(&);
	    case iXOR:	BINOP(^);
	    case iOR:	BINOP(|);
#          undef BINOP
#          define BINOP(OP) {									\
		    oop rhs = pop(), lhs = pop();						\
		    if (is(Float, lhs) || is(Float, rhs))					\
			push(floatValue(lhs) OP floatValue(rhs) ? true : false);		\
		    else									\
			push(integerValue(lhs) OP integerValue(rhs) ? true : false);		\
		    continue;									\
		}
	    case iLT:	BINOP(< );
	    case iLE:	BINOP(<=);
	    case iGE:	BINOP(>=);
	    case iGT:	BINOP(> );
	    case iEQ:	BINOP(==);
	    case iNE:	BINOP(!=);
#          undef BINOP
	    case iGETGVAR: {
		oop operand = code[pc++];
		oop keyval  = assoc(env, operand);
		if (nil != keyval) {
		    push(get(keyval, Pair,tail));
		    continue;
		}
		push(get(operand, Symbol,value));
		continue;
	    }
	    case iSETGVAR: {
		oop operand = code[pc++];
		oop keyval  = assoc(env, operand);
		if (nil != keyval) {
		    set(keyval, Pair,tail, top);
		    continue;
		}
		set(operand, Symbol,value, top);
		continue;
	    }
	    case iCLOSE: {
		oop func = code[pc++];
		push(newClosure(func, env));
		continue;
	    }
	    case iCALL: {
		int     argc = _integerValue(code[pc++]);
		oop func = pop();
		switch (getType(func)) {
		    case Primitive: {
			oop result = get(func, Primitive,function)(argc, stack + sp, nil);
			sp += argc; // pop all arguments
			push(result);
			continue; // next instruction
		    }
		    case Closure: {
			Object  *function    = get(func, Closure,function);
			Object  *environment = get(func, Closure,environment);
			Object  *parameters  = get(function, Function,parameters);
			int      parc        = get(parameters, List,size);
			oop *parv        = get(parameters, List,elements);
			int      parn        = 0;
			while (parn < parc && argc > 0) {
			    environment = newPair(newPair(parv[parn++], pop()), environment);
			    --argc;
			}
			while (parn < parc)
			    environment = newPair(newPair(parv[parn++], nil), environment);
			sp += argc;
			if (fp < 1) fatal("too many function calls");
			--fp;
			frames[fp].env  = env;   env  = environment;
			frames[fp].code = code;  code = get(function, Function,code);
			frames[fp].pc   = pc;    pc   = 0;
			assert(code != 0);
			continue;
		    }
		    default:
			fatal("cannot call value of type %d", getType(func));
		}
		continue;
	    }
	    case iRETURN: {
		assert(fp < 32);
		env  = frames[fp].env;
		code = frames[fp].code;
		pc   = frames[fp].pc;
		++fp;
		continue;
	    }
	    case iJMP: {
		int dest = _integerValue(code[pc++]);
		pc = dest;
		continue;
	    }
	    case iJMPF:	{
		int dest = _integerValue(code[pc++]);
		oop cond = pop();
		if (nil == cond) pc = dest;
		continue;
	    }
	}
    }
    assert(!"this cannot happen");
    return 0;
}

#define EMITo(O)	List_append(program, (O))
#define EMITi(I)	EMITo(newInteger(I))

#define EMIToo(O, P)	(( EMITo(O), EMITo(P) ))
#define EMITio(I, P)	EMIToo(newInteger(I), P)
#define EMITii(I, J)	EMIToo(newInteger(I), newInteger(J))

oop compileFunction(oop exp);

void compileOn(oop exp, oop program, oop cs, oop bs)
{
    switch (getType(exp)) {
	case Undefined:	EMITio(iPUSH, exp);	return;
	case Input:	EMITio(iPUSH, exp);	return;
	case Token:	assert(!"this cannot happen");
	case Integer:	EMITio(iPUSH, exp);	return;
	case Float:	EMITio(iPUSH, exp);	return;
	case Pointer:	assert(!"unimplemented");
	case Array:	assert(!"unimplemented");
	case Struct:	assert(!"unimplemented");
	case Symbol:	EMITio(iGETGVAR, exp);	return;
	case Pair:	EMITio(iPUSH, exp);	return;
	case String:	EMITio(iPUSH, exp);	return;
	case List:	assert(!"unimplemented");
	case Memory:	assert(!"unimplemented");
	case Primitive:	EMITio(iPUSH, exp);	return;
	case Reference: assert(!"unimplemented");
	case Closure:	EMITio(iPUSH, exp);	return;
	case Call: {
	    Object  *args = get(exp, Call,arguments);
	    int      argc = get(args, List,size);
	    oop *argv = get(args, List,elements);
	    for (int n = argc; n--;) compileOn(argv[n], program, cs, bs);
	    compileOn(get(exp, Call,function), program, cs, bs);	    // GETVAR	print
	    EMITii(iCALL, argc);
	    return;
	}
	case Block: {
	    oop statements = get(exp, Block,statements);
	    int      size = get(statements, List,size);
	    if (0 == size) {
		EMITio(iPUSH, nil);
		return;
	    }
	    oop *exps = get(statements, List,elements);
	    for (int i = 0;  i < size - 1;  ++i) {
		compileOn(exps[i], program, cs, bs);
		EMITi(iPOP);
	    }
	    compileOn(exps[size - 1], program, cs, bs);
	    return;
	}
	case Addressof:		assert(!"unimplemented");
	case Dereference:	assert(!"unimplemented");
	case Sizeof:		assert(!"unimplemented");
	case Unary: {
	    compileOn(get(exp, Unary,rhs), program, cs, bs);
	    switch (get(exp, Unary,operator)) {
		case NEG:	EMITi(iNEG);	return;
		case NOT:	EMITi(iNOT);	return;
		case COM:	EMITi(iCOM);	return;
		case PREINC:	assert(!"unimplemented");
		case PREDEC:	assert(!"unimplemented");
		case POSTINC:	assert(!"unimplemented");
		case POSTDEC:	assert(!"unimplemented");
	    }
	    break;
	}
	case Binary: { // MUL{op, lhs, rhs}
	    switch (get(exp, Binary,operator)) {
		case LAND:	assert(!"unimplemented");
		case LOR:	assert(!"unimplemented");
		default:	break;
	    }
	    compileOn(get(exp, Binary,lhs), program, cs, bs);
	    compileOn(get(exp, Binary,rhs), program, cs, bs);
	    switch (get(exp, Binary,operator)) {
		case MUL:	EMITi(iMUL);	return;
		case DIV:	EMITi(iDIV);	return;
		case MOD:	EMITi(iMOD);	return;
		case ADD:	EMITi(iADD);	return;
		case SUB:	EMITi(iSUB);	return;
		case SHL:	EMITi(iSHL);	return;
		case SHR:	EMITi(iSHR);	return;
		case LT:	EMITi(iLT);	return;
		case LE:	EMITi(iLE);	return;
		case GE:	EMITi(iGE);	return;
		case GT:	EMITi(iGT);	return;
		case EQ:	EMITi(iEQ);	return;
		case NE:	EMITi(iNE);	return;
		case BAND:	EMITi(iAND);	return;
		case BXOR:	EMITi(iXOR);	return;
		case BOR:	EMITi(iOR);	return;
		case LAND:
		case LOR:
		    assert(!"unimplemented");
	    }
	}
	case Index:		    assert(!"unimplemented");
	case Member:		    assert(!"unimplemented");
	case Assign: {
	    oop symbol = get(exp, Assign,lhs);
	    oop expr   = get(exp, Assign,rhs);
	    compileOn(expr, program, cs, bs);
	    EMITio(iSETGVAR, symbol);
	    return;
	}

	case Cast: {
	    assert(!"unimplemented");
	    return;
	}

# define LABEL(NAME)	int NAME = get(program, List,size)
# define PATCH(J, L)    List_set(program, J+1, newInteger(L))

	case While: {
	    oop continues = newList();
	    oop breaks    = newList();
	    oop cond = get(exp, While,condition);
	    oop body = get(exp, While,expression);
	    EMITio(iPUSH, nil);
	    LABEL(L1);
	    compileOn(cond, program, cs, bs); // break/continue apply to enclosing loop
	    LABEL(J1);
	    EMITio(iJMPF, nil);
	    EMITi(iPOP);
	    compileOn(body, program, continues, breaks);
	    EMITii(iJMP, L1);
	    LABEL(L2);
	    PATCH(J1, L2);
	    for (int i = get(continues, List,size);  i--;)
		PATCH(_integerValue(get(continues, List,elements)[i]), L1);
	    for (int i = get(breaks, List,size);  i--;)
		PATCH(_integerValue(get(breaks, List,elements)[i]), L2);
	    return;
	}
	case For: {
	    assert(!"unimplemented");
	    return;
	}
	case If: {
	    oop cond   = get(exp, If,condition);
	    oop conseq = get(exp, If,consequent);
	    oop altern = get(exp, If,alternate);
	    compileOn(cond, program, cs, bs);
	    LABEL(J1);
	    EMITio(iJMPF, nil); // L1
	    compileOn(conseq, program, cs, bs);
	    LABEL(J2);
	    EMITio(iJMP, nil); // L2
	    LABEL(L1);
	    compileOn(altern, program, cs, bs);
	    LABEL(L2);
	    PATCH(J1, L1);
	    PATCH(J2, L2);
	    return;
	}
	case Return:	assert(!"unimplemented");
	case Continue: {
	    if (nil == cs) fatal("continue outside loop");
	    EMITio(iPUSH, nil);
	    LABEL(L1);
	    EMITio(iJMP, nil);
	    List_append(cs, newInteger(L1));
	    return;
	}
	case Break: {
	    if (nil == bs) fatal("break outside loop");
	    EMITio(iPUSH, nil);
	    LABEL(L1);
	    EMITio(iJMP, nil);
	    List_append(bs, newInteger(L1));
	    return;
	}
	case Tvoid:	assert(!"unimplemented");    	return;
	case Tchar:	assert(!"unimplemented");    	return;
	case Tshort:	assert(!"unimplemented");    	return;
	case Tint:	assert(!"unimplemented");    	return;
	case Tlong:	assert(!"unimplemented");    	return;
	case Tfloat:	assert(!"unimplemented");    	return;
	case Tdouble:	assert(!"unimplemented");    	return;
	case Tpointer:	assert(!"unimplemented");    	return;
	case Tarray:	assert(!"unimplemented");    	return;
	case Tstruct:	assert(!"unimplemented");    	return;
	case Tfunction:	assert(!"unimplemented");    	return;
	case Tetc:	assert(!"unimplemented");    	return;
	case VarDecls:	assert(!"unimplemented");    	return;
	case TypeDecls:	assert(!"unimplemented");    	return;
	case Scope:	assert(!"this cannot happen");	return;
	case TypeName:	assert(!"unimplemented");    	return;
	case Variable:	assert(!"unimplemented");    	return;
	case Constant:	assert(!"unimplemented");    	return;
	case Function: {
	    assert(0 == get(exp, Function,code));
	    oop prog2 = compileFunction(get(exp, Function,body));
	    set(exp, Function,code, get(prog2, List,elements));
	    EMITio(iCLOSE, exp);
	    return;
	}
    }
}

oop compileFunction(oop exp)
{
    oop program = newList();
    compileOn(exp, program, nil, nil);
    EMITi(iRETURN);
    if (opt_v > 2) disassemble(program);
    return program;
}

oop compile(oop exp) // 6*7
{
    oop program = newList();
    compileOn(exp, program, nil, nil);
    EMITi(iHALT);
    if (opt_v > 2) disassemble(program);
    return program;
}

void replFile(char *name, FILE *file)
{
    input = pushInput(name, file);

    while (input) {
	if (yyparse() && yysval) {
	    if (opt_v > 1) println(yysval);
	    if (!opt_x) {
		oop result = nil;
		if (opt_O) {
		    oop program = compile(yysval);
		    result = execute(program);
		}
		else {
		    switch (nlrPush()) {
			case NLR_INIT:     break;
			case NLR_RETURN:   fatal("return outside function");
			case NLR_CONTINUE: fatal("continue outside loop");
			case NLR_BREAK:    fatal("break outside loop");
		    }
		    if (opt_v > 1) printf("---------------- typecheck\n");
		    assert(1 == List_size(scopes));
		    typeCheck(yysval, nil);
		    assert(1 == List_size(scopes));
		    if (opt_v > 1) printf("---------------- declare\n");
		    result = preval(yysval);
		    assert(1 == List_size(scopes));
		    nlrPop();
		}
		if (opt_v > 0) {
		    printf("=> %s\n", toString(result));
		}
	    }
	}
    }
}

void replPath(char *path)
{
    FILE *file = fopen(path, "r");
    if (!file) fatal("%s: %s", path, strerror(errno));
    replFile(path, file);
}

int main(int argc, char **argv)
{
    setbuf(stdout, 0);

    false    = newInteger(0);
    true     = newInteger(1);
    s_etc    = newSymbol("...");
    heap     = newList();

# define _(X) s_##X = intern(#X);
    _do_primitives(_);
# undef _

    t_void   = newTvoid();
    t_char   = newTchar();
    t_short  = newTshort();
    t_int    = newTint();
    t_long   = newTlong();
    t_float  = newTfloat();
    t_double = newTdouble();
    t_pvoid  = newTpointer(t_void);
    t_pchar  = newTpointer(t_char);
    t_ppchar = newTpointer(t_pchar);
    t_etc    = newTetc();

    tags   = newList();  // struct/union/enum tags
    scopes = newList();  // lexically nested variable scopes

    Scope_begin(); // the global scope

    int argn  = 1;

    while (argn < argc) {
	char *arg = argv[argn];
	if (*arg != '-') break;
	++argn;
	while (*++arg) {
	    switch (*arg) {
		case 'O':	++opt_O;  continue;
		case 'v':	++opt_v;  continue;
		case 'x':	++opt_x;  continue;
		default:	fatal("uknown option '%c'", *arg);
	    }
	}
    }

    oop args  = newList();
    if (argn == argc) fatal("no program file specified");

    char *program = argv[argn++];
    replPath(program);
    List_append(args, newStringWith(program));

    while (argn < argc)
	List_append(args, newStringWith(argv[argn++]));

    int cargs = List_size(args);
    int vsize = sizeof(char *) * cargs;
    oop vargs = newArray(newTarray(t_pchar, newInteger(cargs)),
			 newMemory(malloc(vsize), vsize, 0),
			 cargs);
    List_do(args, arg) {
	char *elts = String_cString(arg);
	oop   mem  = newMemory(elts, get(arg, String,size), 0);
	setArray(vargs, do_index, newPointer(t_pchar, mem, 0));
    }

    args = newList();
    List_append(args, newInteger(cargs));
    List_append(args, vargs);
    List_append(args, newPointer(t_ppchar, newMemory(0, 0, 0), 0));

    oop entry = Scope_lookup(intern("main"));
    if (!entry || isNil(entry)) fatal("main is not defined");
    if (!is(Function, entry))	fatal("main is not a function");

    oop params = get(get(entry, Function,type), Tfunction, parameters);
    switch (List_size(params)) {
	default:
	    fatal("main has too many parameters");
	case 3:
	    if (List_get(params, 2) != t_ppchar)
		fatal("third parameter of main should be 'char **'");
	case 2:
	    if (List_get(params, 1) != t_ppchar)
		fatal("second parameter of main should be 'char **'");
	case 1:
	    if (List_get(params, 0) != t_int)
		fatal("first parameter of main should be 'int'");
	case 0:
	    break;
    }

    set(entry, Function,variadic, 1);

    if (opt_v > 1) printf("---------------- execute\n");
    oop result = apply(entry, args, nil);

    if (!is(Integer, result)) {
	printf("\n=> ");
	println(result);
	fatal("main did not return an integer");
    }

    assert(1 == List_size(scopes));
	//printf("tugi list_do!\n");
    List_do(heap, mem) {
      if (!get(mem, Memory,free))
	printf("allocated memory not freed at end of program: %s\n", toString(mem));
    }

    return _integerValue(result);
}

